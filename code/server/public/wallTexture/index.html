<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="../src/three.js"></script>
    <script src="../src/controller/OrbitControls.js"></script>
    <script src="../src/common/utils.js"></script>
    <script src="../src/common/math.js"></script>

    <!-- 加载构建基础房间需要的数据 -->
    <script src="./data.js"></script>

    <style>
        body{
            margin: 0;
            overflow: hidden;
        }
        #textureWrap {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 120px;
            background: #ccc;
        }
    </style>
</head>
<body>
    <div id="textureWrap">

    </div>
    <div id="WebGL-output"></div>
</body>
<script>
    let canBeSelectedObj = [] // 场景中能被用户选中的对象列表
    let scene = null, camera = null, renderer = null, domElement = null, controller = null
    let roomGroup = null    // 房屋对象组
    let texturePool = {     // 材质池
        door:   [],
        win:    [],
        wall:   [],
        roof:   [],
        floor:  []
    }

    init() // 初始化场景操作
    initRoom() // 初始化构建房屋
    
    
    domElement.addEventListener('click', handleClick)

    //---- function build and put plane

    function handleClick(e) {
        let coords = tranformMouseCoord(e.clientX, e.clientY, domElement)
        let intersects = getSelectedMeshes(coords, camera, canBeSelectedObj)
        if(intersects.length > 0) {
            console.log(intersects[0].object.userData.type)
        }
    }

    function generateWall(wallData) {
        // console.log(wallData)
        let shape = new THREE.Shape() 
        shape.moveTo(wallData.start.x, wallData.start.y)
        for(let i = 0; i < wallData.path.length; i++) { // make path
            let p = wallData.path[i]
            shape.lineTo(p.x, p.y)
        }

        for (let i = 0; i < wallData.children.length; i++) { // make holes
            let item = wallData.children[i]
            let hole = new THREE.Path()
            hole.moveTo(item.start.x, item.start.y)
            for(let j =0; j < item.path.length; j++) { // make hole path
                hole.lineTo(item.path[j].x, item.path[j].y)
            }
            shape.holes.push(hole)
        }

        for(let i = 0;i < wallData.children.length; i++){ // make child ( windows/doors )
            let item = wallData.children[i]
            
            let child = new THREE.Shape() 
            // child.moveTo(item.start.x, item.start.y)
            child.moveTo(0, 0)
            for(let j = 0; j < item.path.length; j++) {
                child.lineTo(item.path[j].x - item.start.x, item.path[j].y)
            }
            let geometry = new THREE.ShapeGeometry( child )
            let color = new THREE.Color( Math.random(), Math.random(), Math.random() )

            let material = null
            if(item.type == 'door') { // sideWall
                material = new THREE.MeshBasicMaterial({ 
                    map: initTexture('/src/images/room/door/2.jpg')
                }) 
            }else if(item.type == 'win'){
                material = new THREE.MeshBasicMaterial({ 
                    map: initTexture('/src/images/room/win/2.jpg')
                }) 
            }else{
                material = new THREE.MeshBasicMaterial({ color }) 
            }
            let mesh = new THREE.Mesh( geometry, material)
           
            mesh.position.copy(wallData.position)
            mesh.rotation.x = wallData.rotation.x
            mesh.rotation.y = wallData.rotation.y
           
            if(wallData.rotation.y == 0){
                mesh.position.x += item.start.x
            }else if(wallData.rotation.y == -Math.PI/2){
                mesh.position.z += item.start.x
            }else if(wallData.rotation.y == -Math.PI){
                mesh.position.x -= item.start.x
            }else if(wallData.rotation.y == (-3*Math.PI/2)){
                mesh.position.z -= item.start.x
            }
            mesh.userData.type = item.type
            canBeSelectedObj.push(mesh)
            roomGroup.add(mesh)
        }

        let geometry = new THREE.ShapeGeometry( shape ) // make wall
        let color = new THREE.Color( Math.random(), Math.random(), Math.random() )
        let material = null
        
        if(wallData.type == 'sideWall' || wallData.type == 'insideWall') { // sideWall
            material = new THREE.MeshBasicMaterial({
                map: initTexture('/src/images/room/wall/1.jpg')
             }) 
        }else if(wallData.type == 'roof'){
            material = new THREE.MeshBasicMaterial({
                map: initTexture('/src/images/room/roof/1.jpg')
             }) 
        }else if(wallData.type == 'floor') {
            material = new THREE.MeshBasicMaterial({
                map: initTexture('/src/images/room/floor/1.jpg')
             }) 
        }else{
            material = new THREE.MeshBasicMaterial({ color }) 
        }

        let mesh = new THREE.Mesh( geometry, material)
        mesh.position.copy(wallData.position)
        mesh.rotation.x = wallData.rotation.x
        mesh.rotation.y = wallData.rotation.y
        mesh.userData.type = wallData.type
        // if(wallData.type == 'sideWall') {
        //     // console.log(mesh)
        // }
        
        canBeSelectedObj.push(mesh)
        roomGroup.add(mesh)
    }

    function init() { // 初始化场景操作
        scene = new THREE.Scene()
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.set(80, 80, 80)
        camera.lookAt(scene.position)
        renderer = new THREE.WebGLRenderer({
            antialias:true, // 开启抗锯齿处理
            alpha:true
        })
        renderer.setClearColor(new THREE.Color(0xEEEEEE))
        renderer.setSize(window.innerWidth,window.innerHeight)
        renderer.shadowMap.enabled = true
        domElement = renderer.domElement
        document.getElementById('WebGL-output').appendChild(domElement)
        controller = new THREE.OrbitControls( camera, domElement )

        var grid = new THREE.GridHelper( 100, 50, 0x444444, 0x888888 );
        scene.add( grid )
        var axesHelper = new THREE.AxesHelper( 40 )
        scene.add( axesHelper )

        roomGroup = new THREE.Group() // 房屋对象组
        renderScene()
    }

    function initRoom() { // 初始化构建房屋
        for(let i = 0;i < data.length;i++) { // 根据数据和相关方法构建房间
            generateWall(data[i])
        }
        let housecenter = getObjectCenter(roomGroup)
        roomGroup.position.set(-housecenter.x, 0, -housecenter.z)
        scene.add(roomGroup)
    }

    function initTexture(src) {
        let loader = new THREE.TextureLoader()
        // let texture = loader.load('/src/images/room/wall/1.jpg')
        let texture = loader.load(src)
        // let texture = loader.load('/src/images/room/win/1.jpg')
        // let texture = loader.load('/src/images/room/win/5.jpg')
        texture.wrapS = THREE.RepeatWrapping
        texture.wrapT = THREE.RepeatWrapping
        // texture.repeat.set( 1, 1 )
        // texture.offset = 0.05
        texture.repeat.set( 1/10, 1/20 )
        // texture.repeat.set( 1/5, 1/5 )
        // texture.repeat.set( 1/10, 1/10 )
        // texture.repeat.set( 1/10, 1/10 )
        return texture
    }
    
    function renderScene(){
        renderer.render(scene,camera)
        requestAnimationFrame(renderScene)
    }
    window.onresize = onResize
    function onResize(){
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth,window.innerHeight)
    }
    
</script>
</html>