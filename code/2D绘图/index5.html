<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        html{
            height: 100%;
        }
        body{
            margin: 0;
            height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #ffff00;
        }
        #leftWrap, #rightWrap{
            width: 20vw;
            height: 40vw;
            background-color: aqua;
        }
        #canWrap {
            position: relative;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
            width: 60vw;
            height: 40vw;
            background-color: #fff;
        }
        #canWrap .can{
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }
        .btn{
            border: 1px solid #0000ff;
            padding: 5px;
            cursor: pointer;
        }
        .btn:hover{
            background-color: aquamarine;
        }
        #currentType {
            position: absolute;
            top: 0;
            display: block;
            text-align: center;
        }
    </style>
</head>
<body>
    <h3 id="currentType">sidewall</h3>
    <div id="leftWrap">
        <div class="btn" onclick="changeType('sidewall')">
            sidewall
            <div class="sideEdit" style="display: none;">
                len: <input id="sideWallLen" type="number">
                <button onclick="setCurrentSideWallLen()">sure</button>
            </div>
            <div class="sideEdit" style="display: none;">
                <button onclick="deleteSidePoint()">delete side point</button>
            </div>
        </div>
        <div class="btn" onclick="changeType('insidewall')">insidewall</div>
        <div class="btn" onclick="changeType('win')">
            win
            <div class="winEdit" style="display: none;">
                toLeft: <input id="winToLeft" type="number">
                <button onclick="setSelectWinPos('toLeft')">sure</button><br/>
                toTop:<input id="winToTop" type="number">
                <button onclick="setSelectWinPos('toTop')">sure</button>
            </div>
            <div class="winEdit" style="display: none;">
                <button onclick="deleteSelectWin()">delete select win</button>
            </div>
        </div>
        <div class="btn" onclick="changeType('door')">
            door
            <div class="doorEdit" style="display: none;">
                toLeft: <input id="doorToLeft" type="number">
                <button onclick="setSelectDoorPos('toLeft')">sure</button><br/>
                toTop:<input id="doorToTop" type="number">
                <button onclick="setSelectDoorPos('toTop')">sure</button>
            </div>
            <div class="doorEdit" style="display: none;">
                <button onclick="deleteSelectDoor()">delete select door</button>
            </div>
        </div>
        <div class="btn" onclick="outData()" style="background-color: red">out data</div>
    </div>
    <div id="canWrap">
        <canvas id="bgplane" class="can"></canvas>
        <canvas id="drawplane" class="can"></canvas>
    </div>
    <div id="rightWrap">
        <div class="btn" onclick="freshCanvas()">fresh</div>
    </div>
</body>
<script>
    let grid_widthCount = 90 // 背景网格线水平格数
    let grid_heightCout = 60 // 背景网格线垂直格数
    let grid_wid_len = null  // 背景网格线水平格宽度
    let grid_hei_len = null  // 背景网格线水平格高度
    let WIDTH = 600, HEIGHT = 400 // 设置整个画布可以容纳的刻度大小
    let wrap = document.getElementById('canWrap')
    let wrapWidth = wrap.clientWidth
    let wrapHeight = wrap.clientHeight // 画布基准大小

    let drawCtx, bgctx // 上下文对象
    let drawCanvas = document.getElementById('drawplane')

    let isSideFinished = false      // 用于标记用户的外墙绘制是否结束
    let isInSideFinished = false    // 用于标记用户的内墙绘制是否结束

    let type = 'sidewall' // sidewall - insidewall - win - door
    let currentType = {
        type: 'sidewall'
    }
    let sideWallDir = 's' // 默认外墙壁的绘制是顺时针的

    let currentWin = null // 当前的窗户
    let selectedWin = null, selectedWinIndex = -1 // 当前选中的窗户
    let currentDoor = null// 当前的门
    let selectedDoor = null, selectedDoorIndex = -1 // 当前选中的门
    let currentSidePoint = null // 当前选中的外墙壁的节点

    let sidewallData = [] // 记录绘画的点的位置 x - y - type
    let insidewallData = [] // x - y - type - inline(l1.x l1.y - l2.x l2.y)
    let canInsertInsideWall = true // 当前能否插入内墙壁的值
    let insideWallItem = null // 内墙壁的数据是一段一段记录的，所以需要一个变量来保存一段墙壁的起点
    let winData = []    // 存放窗户的信息 主要用于canvas的绘图用
    // { wp1: p, wp2: {x: p.x, y: p.y + len}, l1, l2 }
    let doorData = []   // 存放门的信息  主要用于canvas的绘图用
    // { dp1: p, dp2: {x: p.x, y: p.y + len}, l1, l2 }

    initBgGrid() // 初始化背景网格线
    initDrawConfig()

    window.addEventListener('resize', reset)
    
    function initDrawConfig() { // 初始化绘制画布的一些配置
        
        let drawwidth = drawCanvas.clientWidth
        let drawheight = drawCanvas.clientHeight
        drawCanvas.width = drawwidth
        drawCanvas.height = drawheight
        drawCtx = drawCanvas.getContext('2d')

        drawCanvas.addEventListener('click', handleClick) 
        drawCanvas.addEventListener('mouseup', handleUp)
    }

    function handleClick(e) { // 鼠标点击时做的动作
        
        let plane = e.target
        let { x, y } = plane.getBoundingClientRect()
        let px = e.clientX - x
        let py = e.clientY - y 
       
        if(currentType.type == 'sidewall') { // 当前绘制外墙
            if(isSideFinished){ // 如果当前对于外墙壁的绘制已经结束 那么就无法再次进入对外墙壁的操作
                return
            } 
            let lastPoint = sidewallData[sidewallData.length - 1]
            
            if(sidewallData.length > 0) { // 除了第一个点之外，在绘制其他的点的时候都需要对点的位置进行矫正
                let standedPoint = adjustPointPos(lastPoint, { x: px, y: py})
                standedPoint.type = 'sidewall'
                standedPoint.rotation = getPointRotation(lastPoint, standedPoint)
                standedPoint.children = []
                if(isNewSideWallUseful(lastPoint, standedPoint, sidewallData)) { // 当前新增点有效
                    sidewallData.push(standedPoint) // 加点
                }
            }else{
                sidewallData.push({ // 加点（第一个点，第一个点的rotation在加最后一个点的时候赋值）
                    x: px,
                    y: py,
                    type: currentType.type,
                    children: []
                })
            }
            if(currentSidePoint !== null) {
                sidewallData[sidewallData.length - 1] = currentSidePoint
                currentSidePoint = null
                quitSidePointEdit() // 取消外墙壁节点编辑状态
            }
            drawDataToScreen()

        }else if(currentType.type == 'insidewall') { // 当前绘制内墙

            if(!isSideFinished) return // 只有在外墙完成绘制后才能绘制内墙
            let selectWallResult = isSelectSideWall({x: px, y: py}) // 先判断用户有没有选中外墙
            if(selectWallResult.length == 0) selectWallResult = isSelectInSideWall({x: px, y: py}) // 再判断用户有没有选中内墙
            let selectedPointResult = isSelectPoint({ x: px, y: py })
            
            if(selectedPointResult !== null) { // 用户选中了现有墙壁的节点
                if(insideWallItem !== null) { // 用户在完成绘制一段内墙壁时选择的第二个点也在现有墙壁的节点上
                    // 调整点的位置
                    insideWallItem = null
                }else {
                    insideWallItem = {
                        start: { x: selectedPointResult.x, y: selectedPointResult.y },
                        end: {}
                    }
                }
            }else { // 用户没有选中现有的墙壁节点
                if(selectWallResult.length > 0) { // 当前用户选中了一段墙
                 
                    let insidePoint = getInLinePoint(...selectWallResult) // 选中墙的垂足
                    if(insideWallItem !== null) { // 这一段内墙壁已经选中一个点 且再次选中的点在墙壁上
                    
                        let standedPoint = adjustPointPos(insideWallItem.start, { x: insidePoint.x, y: insidePoint.y}) // 调整后的点
                        if(canInsertInsideWall && pointsDistance(insideWallItem.start, { x: standedPoint.x, y: standedPoint.y }) > 8){ // 没有再次选中当前内墙壁的起始点时取消当前内墙壁的绘制
                            
                            // if(isNewInSideWallUseful(insideWallItem.start, standedPoint)) {
                                insideWallItem.end = { x: standedPoint.x, y: standedPoint.y }
                                insidewallData.push({ // 正面的内墙壁
                                    start: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                    end: { x: standedPoint.x, y: standedPoint.y },
                                    children: [],
                                    rotation: getInsideWallRotation(insideWallItem)
                                })
                                insidewallData.push({ // 反面的内墙壁 用户在将绘制的数据转化时会同时多输入一遍数据
                                    end: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                    start: { x: standedPoint.x, y: standedPoint.y },
                                    children: [],
                                    rotation: getInsideWallRotation({
                                        end: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                        start: { x: standedPoint.x, y: standedPoint.y }
                                    })
                                })
                            // }
                        
                        }
                        insideWallItem = null
                    }else { // 这一段内墙壁刚刚开始确定第一个点
                        insideWallItem = {
                            start: { x: insidePoint.x, y: insidePoint.y },
                            end: {}
                        }
                    }
                }else if(isPointInShape({ x: px, y: py }, sidewallData)){ // 用户点击了房间的内部
                    
                    if(insideWallItem !== null) { // 这一段内墙壁已经选中一个点
                        
                        let standedPoint = adjustPointPos(insideWallItem.start, { x: px, y: py})
                       
                        if(canInsertInsideWall && pointsDistance(insideWallItem.start, { x: standedPoint.x, y: standedPoint.y }) > 8){ // 没有再次选中当前内墙壁的起始点时取消当前内墙壁的绘制
                            
                            if(isNewInSideWallUseful(insideWallItem.start, standedPoint)) {
                                insideWallItem.end = { x: standedPoint.x, y: standedPoint.y }
                                insidewallData.push({
                                    start: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                    end: { x: standedPoint.x, y: standedPoint.y },
                                    children: [],
                                    rotation: getInsideWallRotation(insideWallItem)
                                })
                                insidewallData.push({
                                    end: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                    start: { x: standedPoint.x, y: standedPoint.y },
                                    children: [],
                                    rotation: getInsideWallRotation({
                                        end: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                        start: { x: standedPoint.x, y: standedPoint.y }
                                    })
                                })
                            }
                            
                        }
                        insideWallItem = null
                    }else { // 这一段内墙壁刚刚开始确定第一个点
                        insideWallItem = {
                            start: { x: px, y: py },
                            end: {}
                        }
                    }
                }
            }
            
            let lastPoint = sidewallData[sidewallData.length - 1]
            let firstPoint = sidewallData[0]
            drawDataToScreen(true)
        }else if(currentType.type == 'win'){ // 绘制窗户
            if(!isSideFinished) return // 只有在外墙完成绘制后才能绘制窗户
            if(currentWin !== null) { // 当前存在有效的窗户对象
               
                winData.push(currentWin)
                drawDataToScreen(true)
                currentWin = null
            }else { // 目前并没有可供绘制的窗户
                let result = isSelectWin(px, py)
                if(result == null) return // 用户没有选中窗户 直接退出逻辑
                if(JSON.stringify(result[0]) == JSON.stringify(selectedWin)){ // 选中与之前相同的一个窗户
                    hideWinEdit()
                }else{ // 选中不同的窗户 或是之前没有选中窗户
                    showWinEdit(result[0], result[1])
                }
                drawDataToScreen(true)
            }
        }else if(currentType.type == 'door'){
            if(!isSideFinished) return // 只有在外墙完成绘制后才能绘制窗户
            if(currentDoor !== null) {
                
                doorData.push(currentDoor)
                drawDataToScreen(true)
                currentDoor = null
            }else { // 目前并没有可供绘制的门
                let result = isSelectDoor(px, py)
                if(result == null) return // 用户没有选中门 直接退出逻辑
                if(JSON.stringify(result[0]) == JSON.stringify(selectedDoor)){ // 选中与之前相同的一个门
                    hideDoorEdit()
                }else{ // 选中不同的门 或是之前没有选中门
                    showDoorEdit(result[0], result[1])
                }
                drawDataToScreen(true)
            }
        }
        
        drawCanvas.addEventListener('mousemove', handleMove)
    }

    function handleMove(me) { // 在鼠标移动时做的动作
        let plane = me.target
        let { x, y } = plane.getBoundingClientRect()
        let mx = me.clientX - x
        let my = me.clientY - y 

        if(currentType.type == 'sidewall') { // 当前绘制外墙
            let lastPoint = sidewallData[sidewallData.length - 1]
            drawDataToScreen()
            drawLine(drawCtx, { x: mx, y: my }, { x: lastPoint.x, y: lastPoint.y })
            drawPoint(drawCtx, mx, my, true) // 鼠标移动处的红色标记
            if(sidewallData.length > 2 && pointsDistance(sidewallData[0], { x: mx, y: my }) < 16) {
                let helpPoint = adjustLastPointPos()
                drawLine(drawCtx, helpPoint, lastPoint, '#0000ff')
                drawLine(drawCtx, helpPoint, sidewallData[0], '#0000ff')
            }else if(sidewallData.length > 0) {
                let standedPoint = adjustPointPos(lastPoint, { x: mx, y: my })
                drawLine(drawCtx, standedPoint, lastPoint, '#0000ff')
            }
        }else if(currentType.type == 'insidewall') { // 当在绘制内墙壁时移动鼠标
            if(insideWallItem !== null) {
                let lastPoint = sidewallData[sidewallData.length - 1]
                let firstPoint = sidewallData[0]
                drawDataToScreen(true)
                drawPoint(drawCtx, insideWallItem.start.x, insideWallItem.start.y) // 当前内墙壁的起点
                let standedPoint = adjustPointPos(insideWallItem.start, { x: mx, y: my })
                if(isNewInSideWallUseful(insideWallItem.start, standedPoint)){
                    canInsertInsideWall = true
                    drawLine(drawCtx, insideWallItem.start, { x: mx, y: my }) // 辅助链接线
                    drawPoint(drawCtx, mx, my, true) // 鼠标移动处的红色标记
                    drawLine(drawCtx, standedPoint, insideWallItem.start, '#0000ff')
                }else { // 当前不能插入内墙壁的数据
                    canInsertInsideWall = false
                }
            }
        }else if(currentType.type == 'win') { // 当前绘制窗户
            if(!isSideFinished) return // 只有在外墙完成绘制后才能绘制窗户
           
            let result = isSelectSideWall({x: mx, y: my})
            let parentWall = 'sideWall'
            if(result.length == 0){
                parentWall = 'insideWall'
                result = isSelectInSideWall({x: mx, y: my})
            }
            
            if(result.length > 0) { // 用户选中了一段墙
                drawDataToScreen(true)
                let insidePoint = getInLinePoint(...result)
                drawWin({x: insidePoint.x, y: insidePoint.y}, result[1], result[2], parentWall)
            }else {
                currentWin = null
                drawDataToScreen(true)
            }
           
        }else if(currentType.type == 'door') { // 当前绘制门
            
            if(!isSideFinished) return // 只有在外墙完成绘制后才能绘制门
            let parentWall = 'sideWall'
            let result = isSelectSideWall({x: mx, y: my})
            if(result.length == 0) {
                parentWall = 'insideWall'
                result = isSelectInSideWall({x: mx, y: my})
            }
            if(result.length > 0) { // 用户选中了一段墙
                drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
                drawDataToScreen(true)
                let insidePoint = getInLinePoint(...result)
                drawDoor({x: insidePoint.x, y: insidePoint.y}, result[1], result[2], parentWall)
            }else { // 用户没有选中墙
                currentDoor = null
                drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
                drawDataToScreen(true)
            }
        }
     
    }

    function handleUp(ue) { // 在鼠标抬起时做的动作
        let plane = ue.target
        let { x, y } = plane.getBoundingClientRect()
        let ux = ue.clientX - x
        let uy = ue.clientY - y 

        if(currentType.type == 'sidewall') { // 当前绘制外墙
            let lastPoint = sidewallData[sidewallData.length - 1]
            let firstPoint = sidewallData[0]
            if(sidewallData.length > 0 && pointsDistance(lastPoint, { x: ux, y: uy }) < 8) { // 用户重复点击 
                if(!isSideFinished) { // 执行退出当前编辑状态
                    currentSidePoint = lastPoint
                    if(sidewallData.length > 1) { // 并不是确定第一个点
                        
                        getIntoSidePointEdit() // 进入外墙壁节点编辑状态
                    }
                    
                    drawDataToScreen()
                    isSideFinished = true
                }else { //  重新进入当前编辑状态
                    sidewallData.pop()
                    isSideFinished = false
                }
            }
            if(sidewallData.length > 2 && pointsDistance(firstPoint, { x: ux, y: uy }) < 16) { // 至少已经存在三个点 最少四个点构成一个房间
                let p = adjustLastPointPos()
                if(!isEven(sidewallData.length)) {
                    sidewallData.push({
                        type: 'sideWall',
                        x: p.x,
                        y: p.y,
                        rotation: getPointRotation(lastPoint, { x: p.x, y: p.y }),
                        children: []
                    })
                    lastPoint = sidewallData[sidewallData.length - 1]
                }
                lastPoint.x = p.x
                lastPoint.y = p.y
                firstPoint.rotation = getPointRotation(lastPoint, firstPoint)
                // drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
                drawDataToScreen(true)
                isSideFinished = true
            }
        }else if(currentType.type == 'insidewall') {
            console.log(insidewallData)
        }

        drawCanvas.removeEventListener('mousemove', handleMove)
    }

    function freshCanvas() { // 刷新画布
        sidewallData = []
        insidewallData = []
        winData = []
        doorData = []
        isSideFinished = false
        currentWin = null
        currentDoor = null
        insideWallItem = null
        changeType('sidewall')
        drawCtx.clearRect(0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight)
    }

    // --- Draw part start

    function drawDataToScreen(isClose = false) { // 将数据中的点画到画布上 isClose 是否需要当前的外墙壁闭合
        drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
        drawSideWallToScreen(isClose)
        drawInSideWallToScreen()
        drawWinToScreen()
        drawDoorToScreen()
    }

    function drawWinToScreen() { // 将窗户画到画布
        for(let i = 0;i < winData.length;i++) {
            let win = winData[i]
            drawPoint(drawCtx, win.wp1.x, win.wp1.y, false, '#0000ff')
            drawLine(drawCtx, win.wp1, win.wp2, '#0000ff')
            drawPoint(drawCtx, win.wp2.x, win.wp2.y, false, '#0000ff')
        }
    }

    function drawDoorToScreen() { // 将门画到画布
        for(let i = 0;i < doorData.length;i++) {
            let door = doorData[i]
            drawPoint(drawCtx, door.dp1.x, door.dp1.y, false, '#ff0000')
            drawLine(drawCtx, door.dp1, door.dp2, '#ff0000')
            drawPoint(drawCtx, door.dp2.x, door.dp2.y, false, '#ff0000')
        }
    }

    function drawSideWallToScreen(isClose) { // 将外墙画到屏幕上
        for(let i = 0;i < sidewallData.length;i++) {
            let point = sidewallData[i]
            let nextPoint = sidewallData[i+1]
            drawPoint(drawCtx, point.x, point.y)
            if(nextPoint !== undefined) { // 当存在下一个顶点的时候
                drawLine(drawCtx, point, nextPoint)
            }
        }
        if(isClose && sidewallData.length > 0) { // 如果需要当前的外墙壁闭合
            drawLine(drawCtx, sidewallData[0], sidewallData[sidewallData.length - 1])
        }
    }

    function drawInSideWallToScreen() { // 将内墙画到屏幕上
        for(let i = 0;i < insidewallData.length;i++) {
            let item = insidewallData[i]
            drawPoint(drawCtx, item.start.x, item.start.y)
            drawLine(drawCtx, item.start, item.end)
            drawPoint(drawCtx, item.end.x, item.end.y)
        }
    }

    function drawPoint(ctx, x, y, s = false, color = '#000000') { // 根据传入的坐标在指定的上下文绘制点, s 参数表示当前点是否被选中，默认未被选中
        ctx.beginPath()
        ctx.fillStyle = color
        ctx.strokeStyle = color
        if(s) {
            ctx.fillStyle = '#ff0000'
            ctx.strokeStyle = '#ff0000'
        }
        ctx.arc(x, y, 1.5, 0, 2*Math.PI)
        ctx.fill()
        ctx.beginPath()
        ctx.arc(x, y, 3.5, 0, 2*Math.PI)
        ctx.stroke()
        ctx.fillStyle = '#000000'
        ctx.strokeStyle = '#000000'
        if(s) {
            ctx.fillStyle = '#000000'
            ctx.strokeStyle = '#000000'
        }
    }

    function drawLine(ctx, from, to, color = '#000000') { // 从指定的上下文中，根据传入的两个点的坐标画线
        ctx.beginPath()
        ctx.strokeStyle = color
        ctx.moveTo(from.x, from.y)
        ctx.lineTo(to.x, to.y)
        ctx.stroke()
        ctx.strokeStyle = '#000000'
    }

    function drawWin(p, l1, l2, parentWall) { // 绘制窗户 主要用于用户在移动鼠标的时候作辅助提示 默认窗子的宽为 20/1m 
        let len = 10
        if(l1.x == l2.x) { // 窗户在垂直的墙面上
            if(p.y + len <= Math.max(l1.y, l2.y) && !isCrashOtherWinOrDoor(p, {x: p.x, y: p.y + len})) { // 向上画窗户
                let connentResult = judgeConnectWin(p, {x: p.x, y: p.y + len}, 'up', len)
               
                if(connentResult.length > 0) {
                    drawPoint(drawCtx, connentResult[0].x, connentResult[0].y, false, '#0000ff')
                    drawPoint(drawCtx, connentResult[1].x, connentResult[1].y, false, '#0000ff')
                    if(l1.y > l2.y) {
                        currentWin = { wp1: connentResult[1], wp2: connentResult[0], l1, l2, parentWall }
                        return
                    }else {
                        currentWin = { wp1: connentResult[0], wp2: connentResult[1], l1, l2, parentWall }
                        return
                    }
                }else {
                    drawPoint(drawCtx, p.x, p.y, false, '#0000ff')
                    drawPoint(drawCtx, p.x, p.y + len, false, '#0000ff')
                    if(l1.y > l2.y) {
                        currentWin = { wp1: {x: p.x, y: p.y + len}, wp2: p, l1, l2, parentWall }
                        return
                    }else {
                        currentWin = { wp1: p, wp2: {x: p.x, y: p.y + len}, l1, l2, parentWall }
                        return
                    }
                }
            }else if(p.y - len >= Math.min(l1.y, l2.y) && !isCrashOtherWinOrDoor(p, {x: p.x, y: p.y - len})) { // 向下画窗户
                let connentResult = judgeConnectWin(p, {x: p.x, y: p.y - len}, 'down', len)
                
                if(connentResult.length > 0) {
                    drawPoint(drawCtx, connentResult[0].x, connentResult[0].y, false, '#0000ff')
                    drawPoint(drawCtx, connentResult[1].x, connentResult[1].y, false, '#0000ff')
                    if(l1.y > l2.y) {
                        currentWin = { wp1: connentResult[0], wp2: connentResult[1], l1, l2, parentWall }
                    }else {
                        currentWin = { wp1: connentResult[1], wp2: connentResult[0], l1, l2, parentWall }
                    }
                }else {
                    drawPoint(drawCtx, p.x, p.y, false, '#0000ff')
                    drawPoint(drawCtx, p.x, p.y - len, false, '#0000ff')
                    if(l1.y > l2.y) {
                        currentWin = { wp1: p, wp2: {x: p.x, y: p.y - len}, l1, l2, parentWall }
                    }else {
                        currentWin = { wp1: {x: p.x, y: p.y - len}, wp2: p, l1, l2, parentWall }
                    }
                }
            }
        }else{ // 窗户在水平的墙面上
            
            if(p.x + len <= Math.max(l1.x, l2.x) && !isCrashOtherWinOrDoor(p, {x: p.x + len, y: p.y})) { // 向左画窗户
                let connentResult = judgeConnectWin(p, {x: p.x + len, y: p.y}, 'right', len)
               
                if(connentResult.length > 0) {
                    
                    drawPoint(drawCtx, connentResult[0].x, connentResult[0].y, false, '#0000ff')
                    drawPoint(drawCtx, connentResult[1].x, connentResult[1].y, false, '#0000ff')
                    if(l1.x > l2.x) {
                        currentWin = { wp1: connentResult[1], wp2: connentResult[0], l1, l2, parentWall }
                        return
                    }else {
                        currentWin = { wp1: connentResult[0], wp2: connentResult[1], l1, l2, parentWall }
                        return
                    }
                }else{
                    drawPoint(drawCtx, p.x, p.y, false, '#0000ff')
                    drawPoint(drawCtx, p.x + len, p.y, false, '#0000ff')
                    if(l1.x > l2.x) {
                        currentWin = { wp1: {x: p.x + len, y: p.y}, wp2: p, l1, l2, parentWall }
                        return
                    }else {
                        currentWin = { wp1: p, wp2: {x: p.x + len, y: p.y}, l1, l2, parentWall }
                        return
                    }
                }
                
            }else if(p.x - len >= Math.min(l1.x, l2.x) && !isCrashOtherWinOrDoor(p, {x: p.x - len, y: p.y})) { // 向右画窗户
                let connentResult = judgeConnectWin(p, {x: p.x - len, y: p.y}, 'left', len)
                if(connentResult.length > 0) {
                    drawPoint(drawCtx, connentResult[0].x, connentResult[0].y, false, '#0000ff')
                    drawPoint(drawCtx, connentResult[1].x, connentResult[1].y, false, '#0000ff')
                    if(l1.x > l2.x) {
                        currentWin = { wp1: connentResult[0], wp2: connentResult[1], l1, l2, parentWall }
                        return
                    }else {
                        currentWin = { wp1: connentResult[1], wp2: connentResult[0], l1, l2, parentWall }
                        return
                    }
                }else{
                    drawPoint(drawCtx, p.x, p.y, false, '#0000ff')
                    drawPoint(drawCtx, p.x - len, p.y, false, '#0000ff')
                    if(l1.x > l2.x) {
                        currentWin = { wp1: p, wp2: {x: p.x + len, y: p.y}, l1, l2, parentWall }
                        return
                    }else {
                        currentWin = { wp1: {x: p.x + len, y: p.y}, wp2: p, l1, l2, parentWall }
                        return
                    }
                }
                
            }
        }
        currentWin = null // 当前的绘制存在冲突的时候 清除之前的对象
    }

    function drawDoor(p, l1, l2, parentWall) { // 绘制门
        let len = 10
        if(l1.x == l2.x) { // 在垂直的墙面上
            if(p.y + len <= Math.max(l1.y, l2.y) && !isCrashOtherWinOrDoor(p, {x: p.x, y: p.y + len})) { // 向上画
                let connentResult = judgeConnectDoor(p, {x: p.x, y: p.y + len}, 'up', len)
               
                if(connentResult.length > 0) {
                    drawPoint(drawCtx, connentResult[0].x, connentResult[0].y, false, '#ff0000')
                    drawPoint(drawCtx, connentResult[1].x, connentResult[1].y, false, '#ff0000')
                    if(l1.y > l2.y) {
                        currentDoor = { dp1: connentResult[1], dp2: connentResult[0], l1, l2, parentWall }
                        return
                    }else {
                        currentDoor = { dp1: connentResult[0], dp2: connentResult[1], l1, l2, parentWall }
                        return
                    }
                }else {
                    drawPoint(drawCtx, p.x, p.y, false, '#ff0000')
                    drawPoint(drawCtx, p.x, p.y + len, false, '#ff0000')
                    if(l1.y > l2.y) {
                        currentDoor = { dp1: {x: p.x, y: p.y + len}, dp2: p, l1, l2, parentWall }
                        return
                    }else {
                        currentDoor = { dp1: p, dp2: {x: p.x, y: p.y + len}, l1, l2, parentWall }
                        return
                    }
                }
            }else if(p.y - len >= Math.min(l1.y, l2.y) && !isCrashOtherWinOrDoor(p, {x: p.x, y: p.y - len})) { // 向下画
                let connentResult = judgeConnectDoor(p, {x: p.x, y: p.y - len}, 'down', len)
                
                if(connentResult.length > 0) {
                    drawPoint(drawCtx, connentResult[0].x, connentResult[0].y, false, '#ff0000')
                    drawPoint(drawCtx, connentResult[1].x, connentResult[1].y, false, '#ff0000')
                    if(l1.y > l2.y) {
                        currentDoor = { dp1: connentResult[0], dp2: connentResult[1], l1, l2, parentWall }
                        return
                    }else {
                        currentDoor = { dp1: connentResult[1], dp2: connentResult[0], l1, l2, parentWall }
                        return
                    }
                }else {
                    drawPoint(drawCtx, p.x, p.y, false, '#ff0000')
                    drawPoint(drawCtx, p.x, p.y - len, false, '#ff0000')
                    if(l1.y > l2.y) {
                        currentDoor = { dp1: p, dp2: {x: p.x, y: p.y - len}, l1, l2, parentWall }
                        return
                    }else {
                        currentDoor = { dp1: {x: p.x, y: p.y - len}, dp2: p, l1, l2, parentWall }
                        return
                    }
                }
            }
        }else{ // 在的水平墙面上
            if(p.x + len <= Math.max(l1.x, l2.x) && !isCrashOtherWinOrDoor(p, {x: p.x + len, y: p.y})) { // 向左画
                let connentResult = judgeConnectDoor(p, {x: p.x + len, y: p.y}, 'right', len)
             
                if(connentResult.length > 0) {
                    drawPoint(drawCtx, connentResult[0].x, connentResult[0].y, false, '#ff0000')
                    drawPoint(drawCtx, connentResult[1].x, connentResult[1].y, false, '#ff0000')
                    if(l1.x > l2.x) {
                        currentDoor = { dp1: connentResult[1], dp2: connentResult[0], l1, l2, parentWall }
                        return
                    }else {
                        currentDoor = { dp1: connentResult[0], dp2: connentResult[1], l1, l2, parentWall }
                        return
                    }
                }else{
                    drawPoint(drawCtx, p.x, p.y, false, '#ff0000')
                    drawPoint(drawCtx, p.x + len, p.y, false, '#ff0000')
                    if(l1.x > l2.x) {
                        currentDoor = { dp1: {x: p.x + len, y: p.y}, dp2: p, l1, l2, parentWall }
                        return
                    }else {
                        currentDoor = { dp1: p, dp2: {x: p.x + len, y: p.y}, l1, l2, parentWall }
                        return
                    }
                }
                
            }else if(p.x - len >= Math.min(l1.x, l2.x) && !isCrashOtherWinOrDoor(p, {x: p.x - len, y: p.y})) { // 向右画
                let connentResult = judgeConnectDoor(p, {x: p.x - len, y: p.y}, 'left', len)
                
                if(connentResult.length > 0) {
                    drawPoint(drawCtx, connentResult[0].x, connentResult[0].y, false, '#ff0000')
                    drawPoint(drawCtx, connentResult[1].x, connentResult[1].y, false, '#ff0000')
                    if(l1.x > l2.x) {
                        currentDoor = { dp1: connentResult[0], dp2: connentResult[1], l1, l2, parentWall }
                        return
                    }else {
                        currentDoor = { dp1: connentResult[1], dp2: connentResult[0], l1, l2, parentWall }
                        return
                    }
                }else{
                    drawPoint(drawCtx, p.x, p.y, false, '#ff0000')
                    drawPoint(drawCtx, p.x - len, p.y, false, '#ff0000')
                    if(l1.x > l2.x) {
                        currentDoor = { dp1: p, dp2: {x: p.x - len, y: p.y}, l1, l2, parentWall }
                        return
                    }else {
                        currentDoor = { dp1: {x: p.x - len, y: p.y}, dp2: p, l1, l2, parentWall }
                        return
                    }
                }
            }
        }
        currentDoor = null // 当前的绘制存在冲突的时候 清除之前的对象
    }

    // --- Draw part end

    // --- Edit sideWall start

    function getIntoSidePointEdit() { // 进入外墙壁节点编辑状态
        let htmlNodes = document.querySelectorAll('.sideEdit')
        htmlNodes.forEach(e => e.style.display = 'block')
        let lenInput = document.getElementById('sideWallLen')
        let lastPoint = sidewallData[sidewallData.length - 1]
        let prePoint = sidewallData[sidewallData.length - 2]
        if(lastPoint.x == prePoint.x){ // 当前的墙壁垂直
            lenInput.value = Math.abs(lastPoint.y - prePoint.y)
        }else if(lastPoint.y == prePoint.y) { // 当前的墙壁水平
            lenInput.value = Math.abs(lastPoint.x - prePoint.x)
        }
    }

    function quitSidePointEdit() { // 取消外墙壁节点编辑状态
        let htmlNodes = document.querySelectorAll('.sideEdit')
        htmlNodes.forEach(e => e.style.display = 'none')
    }

    function setCurrentSideWallLen() { // 通过当前外墙壁的节点来设置当前外墙壁的长度
        
        let value = document.getElementById('sideWallLen').value // 当前输入框中表示的外墙壁节点的长度
        if(value !== ''){
            let lastPoint = sidewallData[sidewallData.length - 1] // 当前的外墙壁节点 也是目前的最后一个外墙壁的节点
            let prePoint = sidewallData[sidewallData.length - 2]
            let len = JSON.parse(value) // 当前这一段外墙壁的长度
            if(len < 0) return // 若设置墙壁的长度小于零 那么认为当前设置墙壁长度的操作是无效的 
            if(lastPoint.x == prePoint.x){ // 当前的墙壁垂直
               
                if(lastPoint.y > prePoint.y) { // 当前点在前面一个点的下面
                    lastPoint.y = prePoint.y + len
                }else { // 当前点在前面一个点的上面
                    lastPoint.y = prePoint.y - len
                }
            }else if(lastPoint.y == prePoint.y) { // 当前的墙壁水平
               
                if(lastPoint.x > prePoint.x) { // 当前点在前一个点的右边
                    lastPoint.x = prePoint.x + len
                }else { // 当前点在前一个点的左边
                    lastPoint.x = prePoint.x - len
                }
            }
            drawDataToScreen()
        }else {
            console.log('enpty')
        }
        
    }

    function deleteSidePoint() { // 删除当前的外墙壁的节点 同时也是当前外墙壁中的最后一个节点
        sidewallData.pop()
        if(sidewallData.length > 0) {
            currentSidePoint = sidewallData[sidewallData.length - 1]
        }
        drawDataToScreen()
        quitSidePointEdit()
    }

    // --- Edit sideWall end

    // --- Edit win start

    function isSelectWin(x, y) { // 判断用户是否选中了一个窗户 若选中则返回当前选中窗户对象的引用和排序
        let parentWall = 'sideWall'
        let selectResult = isSelectSideWall({x, y})
        if(selectResult.length == 0){ // 如果用户没有选中外墙壁
            parentWall = 'insideWall'
            selectResult = isSelectInSideWall({x, y})
            if(selectResult.length == 0) { // 如果用户还没有选中内墙壁
                return null // 用户没有选中窗户
            }
        }
        let [p, l1, l2] = selectResult
        p = getInLinePoint(...selectResult) // 得到对应在墙壁上的点
        
        for(let i = 0;i < winData.length;i++) {
            let win = winData[i]
            if(win.parentWall == parentWall) {
                if(p.x == win.wp1.x && p.x == win.wp2.x && p.y > Math.min(win.wp1.y, win.wp2.y) && p.y < Math.max(win.wp1.y, win.wp2.y)) {
                    return [win, i]
                }
                if(p.y == win.wp1.y && p.y == win.wp2.y && p.x > Math.min(win.wp1.x, win.wp2.x) && p.x < Math.max(win.wp1.x, win.wp2.x)) {
                    return [win, i]
                }
            }
        }
        
        return null // 用户没有选中窗户
    }

    function showWinEdit(result, index){ // 打开窗户编辑面板
        let htmlNodes = document.querySelectorAll('.winEdit')
        htmlNodes.forEach(e => e.style.display = 'block')
        selectedWin = result
        selectedWinIndex = index
        let toLeftInput = document.getElementById('winToLeft')
        let toTopInput = document.getElementById('winToTop')
        if(result.wp1.x == result.wp2.x) { // 窗户垂直
            toLeftInput.value = 0 // 垂直窗户无法水平移动
            toTopInput.value = Math.min(result.wp1.y, result.wp2.y) -  Math.min(result.l1.y, result.l2.y)
        }else{ // 窗户水平
            toTopInput.value = 0 // 水平窗户无法垂直移动
            toLeftInput.value = Math.min(result.wp1.x, result.wp2.x) - Math.min(result.l1.x, result.l2.x)
        }
    }

    function hideWinEdit() { // 关闭窗户编辑面板
        let htmlNodes = document.querySelectorAll('.winEdit')
        htmlNodes.forEach(e => e.style.display = 'none')
        selectedWin = null
        selectedWinIndex = -1
    }

    function deleteSelectWin() { // 删除当前选中的窗户
        if(selectedWinIndex == -1) return // 当前没有选中的窗户
        winData.splice(selectedWinIndex, 1)
        drawDataToScreen(true)
        hideWinEdit()
    }

    function setSelectWinPos(dir) { // 调整当前选中的窗户的位置
        if(selectedWin == null) return // 若当前没有选中的窗户 那么就结束方法
        if(dir == 'toLeft' && selectedWin.wp1.y == selectedWin.wp2.y) { // toLeft winToLeft 水平
            let input = document.getElementById('winToLeft')
            if(input.value !== '') {
                let targetToLeft = JSON.parse(input.value)
                let currentToLeft = Math.min(selectedWin.wp1.x, selectedWin.wp2.x) - Math.min(selectedWin.l1.x, selectedWin.l2.x)
                let wp1x = selectedWin.wp1.x + (targetToLeft - currentToLeft) // 同时水平移动后的位置
                let wp2x = selectedWin.wp2.x + (targetToLeft - currentToLeft)
                let f = isCrashOtherWinOrDoor( 
                        {
                            x: wp1x, 
                            y: selectedWin.wp1.y
                        },
                            {
                            x: wp2x,
                            y: selectedWin.wp2.y
                        },true,
                        selectedWin.wp1,
                        selectedWin.wp2)
                if(targetToLeft < 0 || f || 
                    Math.min(selectedWin.l1.x, selectedWin.l2.x) > Math.min(wp1x, wp2x) || 
                    Math.max(selectedWin.l1.x, selectedWin.l2.x) < Math.max(wp1x, wp2x)) {
                    input.value = currentToLeft
                    return
                }else{
                    selectedWin.wp1.x += (targetToLeft - currentToLeft)
                    selectedWin.wp2.x += (targetToLeft - currentToLeft)
                    drawDataToScreen(true)
                }
            }
        }else if(dir == 'toTop' && selectedWin.wp1.x == selectedWin.wp2.x){ // toTop winToTop 垂直
            let input = document.getElementById('winToTop')
            if(input.value !== '') {
                let targetToTop = JSON.parse(input.value)
                let currentToTop = Math.min(selectedWin.wp1.y, selectedWin.wp2.y) -  Math.min(selectedWin.l1.y, selectedWin.l2.y)
                let wp1y = selectedWin.wp1.y + (targetToTop - currentToTop) // 同时水平移动后的位置
                let wp2y = selectedWin.wp2.y + (targetToTop - currentToTop)
                let f = isCrashOtherWinOrDoor( 
                        {
                            x: selectedWin.wp1.x, 
                            y: wp1y
                        },
                            {
                            x: selectedWin.wp2.x,
                            y: wp2y
                        },true,
                        selectedWin.wp1,
                        selectedWin.wp2)
                if(targetToTop < 0 || f || 
                    Math.min(selectedWin.l1.y, selectedWin.l2.y) > Math.min(wp1y, wp2y) || 
                    Math.max(selectedWin.l1.y, selectedWin.l2.y) < Math.max(wp1y, wp2y)) {
                    input.value = currentToTop
                    return
                }else{
                    selectedWin.wp1.y += (targetToTop - currentToTop)
                    selectedWin.wp2.y += (targetToTop - currentToTop)
                    drawDataToScreen(true)
                }
            }
        }
    }

    // --- Edit win end

    // --- Edit door start

    function isSelectDoor(x, y) { // 判断用户是否选中了一个门 若选中则从当前的门数据中取出这个门用来操作
        let parentWall = 'sideWall'
        let selectResult = isSelectSideWall({x, y})
        if(selectResult.length == 0){ // 如果用户没有选中外墙壁
            parentWall = 'insideWall'
            selectResult = isSelectInSideWall({x, y})
            if(selectResult.length == 0) { // 如果用户还没有选中内墙壁
                return null // 用户没有选中门
            }
        }
        let [p, l1, l2] = selectResult
        p = getInLinePoint(...selectResult) // 得到对应在墙壁上的点
        
        for(let i = 0;i < doorData.length;i++) {
            let door = doorData[i]
            if(door.parentWall == parentWall) {
                if(p.x == door.dp1.x && p.x == door.dp2.x && p.y > Math.min(door.dp1.y, door.dp2.y) && p.y < Math.max(door.dp1.y, door.dp2.y)) {
                    return [door, i]
                }
                if(p.y == door.dp1.y && p.y == door.dp2.y && p.x > Math.min(door.dp1.x, door.dp2.x) && p.x < Math.max(door.dp1.x, door.dp2.x)) {
                    return [door, i]
                }
            }
        }
        
        return null // 用户没有选中窗户
    }

    function showDoorEdit(result, index) { // 打门编辑面板
        let htmlNodes = document.querySelectorAll('.doorEdit')
        htmlNodes.forEach(e => e.style.display = 'block')
        selectedDoor = result
        selectedDoorIndex = index
        let toLeftInput = document.getElementById('doorToLeft')
        let toTopInput = document.getElementById('doorToTop')
        if(result.dp1.x == result.dp2.x) { // 窗户垂直
            toLeftInput.value = 0 // 垂直窗户无法水平移动
            toTopInput.value = Math.min(result.dp1.y, result.dp2.y) -  Math.min(result.l1.y, result.l2.y)
        }else{ // 窗户水平
            toTopInput.value = 0 // 水平窗户无法垂直移动
            toLeftInput.value = Math.min(result.dp1.x, result.dp2.x) - Math.min(result.l1.x, result.l2.x)
        }
    }

    function hideDoorEdit(){ // 关闭门编辑面板
        let htmlNodes = document.querySelectorAll('.doorEdit')
        htmlNodes.forEach(e => e.style.display = 'none')
        selectedDoor = null
        selectedDoorIndex = -1
    }

    function deleteSelectDoor() {  // 删除当前选中的门
        if(selectedDoorIndex == -1) return // 当前没有选中的门
        doorData.splice(selectedDoorIndex, 1)
        drawDataToScreen(true)
        hideDoorEdit()
    }

    function setSelectDoorPos(dir) { // 调整当前选中的门的位置
        if(selectedDoor == null) return // 若当前没有选中的窗户 那么就结束方法
        if(dir == 'toLeft' && selectedDoor.dp1.y == selectedDoor.dp2.y) { // toLeft doorToLeft 水平
            let input = document.getElementById('doorToLeft')
            if(input.value !== '') {
                let targetToLeft = JSON.parse(input.value)
                let currentToLeft = Math.min(selectedDoor.dp1.x, selectedDoor.dp2.x) - Math.min(selectedDoor.l1.x, selectedDoor.l2.x)
                let dp1x = selectedDoor.dp1.x + (targetToLeft - currentToLeft) // 同时水平移动后的位置
                let dp2x = selectedDoor.dp2.x + (targetToLeft - currentToLeft)
                let f = isCrashOtherWinOrDoor( 
                        {
                            x: dp1x, 
                            y: selectedDoor.dp1.y
                        },
                            {
                            x: dp2x,
                            y: selectedDoor.dp2.y
                        },true,
                        selectedDoor.dp1,
                        selectedDoor.dp2)
                if(targetToLeft < 0 || f || 
                    Math.min(selectedDoor.l1.x, selectedDoor.l2.x) > Math.min(dp1x, dp2x) || 
                    Math.max(selectedDoor.l1.x, selectedDoor.l2.x) < Math.max(dp1x, dp2x)) {
                    input.value = currentToLeft
                    return
                }else{
                    selectedDoor.dp1.x += (targetToLeft - currentToLeft)
                    selectedDoor.dp2.x += (targetToLeft - currentToLeft)
                    drawDataToScreen(true)
                }
            }
        }else if(dir == 'toTop' && selectedDoor.dp1.x == selectedDoor.dp2.x){ // toTop doorToTop 垂直
            let input = document.getElementById('doorToTop')
            if(input.value !== '') {
                let targetToTop = JSON.parse(input.value)
                let currentToTop = Math.min(selectedDoor.dp1.y, selectedDoor.dp2.y) -  Math.min(selectedDoor.l1.y, selectedDoor.l2.y)
                let dp1y = selectedDoor.dp1.y + (targetToTop - currentToTop) // 同时水平移动后的位置
                let dp2y = selectedDoor.dp2.y + (targetToTop - currentToTop)
                let f = isCrashOtherWinOrDoor( 
                        {
                            x: selectedDoor.dp1.x, 
                            y: dp1y
                        },
                            {
                            x: selectedDoor.dp2.x,
                            y: dp2y
                        },true,
                        selectedDoor.dp1,
                        selectedDoor.dp2)
                if(targetToTop < 0 || f || 
                    Math.min(selectedDoor.l1.y, selectedDoor.l2.y) > Math.min(dp1y, dp2y) || 
                    Math.max(selectedDoor.l1.y, selectedDoor.l2.y) < Math.max(dp1y, dp2y)) {
                    input.value = currentToTop
                    return
                }else{
                    selectedDoor.dp1.y += (targetToTop - currentToTop)
                    selectedDoor.dp2.y += (targetToTop - currentToTop)
                    drawDataToScreen(true)
                }
            }
        }
    }

    // --- Edit door end

    function isCrashOtherWinOrDoor(p1, p2, isSetPosition = false, lp1=undefined, lp2=undefined) { // 与其他的窗户和门之间是否会发生碰撞 p1-p2 表示一扇门或是一扇窗
        for(let i = 0;i< winData.length;i++) {
            let win = winData[i]
            if(p1.x == p2.x && win.wp1.x == win.wp2.x && p1.x == win.wp1.x) { // 垂直
                if((Math.abs(p1.y - p2.y) + Math.abs(win.wp1.y - win.wp2.y)) > 
                (Math.max(p1.y,p2.y,win.wp1.y,win.wp2.y) - Math.min(p1.y,p2.y,win.wp1.y,win.wp2.y)) ) { // 有重叠部分
                    if(isSetPosition) {
                        if(Math.min(lp1.y, lp2.y) == Math.min(win.wp1.y, win.wp2.y) &&
                            Math.max(lp1.y, lp2.y) == Math.max(win.wp1.y, win.wp2.y)) {
                                // continue
                        }else{
                            return true // 发生碰撞
                        }
                    }else{
                        return true // 发生碰撞
                    }
                }
            }
            if(p1.y == p2.y && win.wp1.y == win.wp2.y && p1.y == win.wp1.y) { // 水平
                if((Math.abs(p1.x - p2.x) + Math.abs(win.wp1.x - win.wp2.x)) > 
                (Math.max(p1.x,p2.x,win.wp1.x,win.wp2.x) - Math.min(p1.x,p2.x,win.wp1.x,win.wp2.x)) ) { // 有重叠部分
                    if(isSetPosition) {
                        if(Math.min(lp1.x, lp2.x) == Math.min(win.wp1.x, win.wp2.x) &&
                            Math.max(lp1.x, lp2.x) == Math.max(win.wp1.x, win.wp2.x)) {
                        }else{
                            return true // 发生碰撞
                        }
                    }else{
                        return true // 发生碰撞
                    }
                }
            }
        } 

        for(let i = 0;i < doorData.length;i++) {
            let door = doorData[i]
            if(p1.x == p2.x && door.dp1.x == door.dp2.x && p1.x == door.dp1.x) { // 垂直
                if((Math.abs(p1.y - p2.y) + Math.abs(door.dp1.y - door.dp2.y)) > 
                (Math.max(p1.y,p2.y,door.dp1.y,door.dp2.y) - Math.min(p1.y,p2.y,door.dp1.y,door.dp2.y)) ) { // 有重叠部分
                    // return true // 发生碰撞
                    if(isSetPosition) {
                        if(Math.min(lp1.y, lp2.y) == Math.min(door.dp1.y, door.dp2.y) &&
                            Math.max(lp1.y, lp2.y) == Math.max(door.dp1.y, door.dp2.y)) {
                        }else{
                            return true // 发生碰撞
                        }
                    }else{
                        return true // 发生碰撞
                    }
                }
            }
            if(p1.y == p2.y && door.dp1.y == door.dp2.y && p1.y == door.dp1.y) { // 水平
                if((Math.abs(p1.x - p2.x) + Math.abs(door.dp1.x - door.dp2.x)) > 
                (Math.max(p1.x,p2.x,door.dp1.x,door.dp2.x) - Math.min(p1.x,p2.x,door.dp1.x,door.dp2.x)) ) { // 有重叠部分
                    // return true // 发生碰撞
                    if(isSetPosition) {
                        if(Math.min(lp1.x, lp2.x) == Math.min(door.dp1.x, door.dp2.x) &&
                            Math.max(lp1.x, lp2.x) == Math.max(door.dp1.x, door.dp2.x)) {
                        }else{
                            return true // 发生碰撞
                        }
                    }else{
                        return true // 发生碰撞
                    }
                }
            }
        }
        return false // 没有发生碰撞
    }

    function judgeConnectWin(p1, p2, dir, len) { // 判断是否要与其他的窗户连接 参数 dir 表示 p1-p2 的方向
        for(let i = 0;i< winData.length;i++) {
            let win = winData[i]
            if(p1.x == p2.x && win.wp1.x == win.wp2.x && p1.x == win.wp1.x) { // 垂直
                if(dir == 'up') { // p1.y < p2.y
                    if(win.wp1.y < win.wp2.y) {
                        if(Math.abs(p2.y - win.wp1.y) < 8) {
                            return [ { x: p1.x, y: win.wp1.y - len }, { x: p1.x, y: win.wp1.y } ]
                        }else if(Math.abs(p1.y - win.wp2.y) < 8) {
                            return [ { x: p1.x, y: win.wp2.y }, { x: p1.x, y: win.wp2.y + len } ]
                        }
                    }else{
                        if(Math.abs(p2.y - win.wp2.y) < 8) {
                            return [ { x: p1.x, y: win.wp2.y - len }, { x: p1.x, y: win.wp2.y } ]
                        }else if(Math.abs(p1.y - win.wp1.y) < 8) {
                            return [ { x: p1.x, y: win.wp1.y }, { x: p1.x, y: win.wp1.y + len } ]
                        }
                    }
                }else if(dir == 'down'){ // p1.y > p2.y
                    if(win.wp1.y < win.wp2.y) {
                        if(Math.abs(p1.y - win.wp1.y) < 8) {
                            return [ { x: p1.x, y: win.wp1.y }, { x: p1.x, y: win.wp1.y - len } ]
                        }else if(Math.abs(p2.y - win.wp2.y) < 8) {
                            return [ { x: p1.x, y: win.wp2.y + len }, { x: p1.x, y: win.wp2.y } ]
                        }
                    }else{
                        if(Math.abs(p1.y - win.wp2.y) < 8) {
                            return [ { x: p1.x, y: win.wp2.y }, { x: p1.x, y: win.wp2.y - len } ]
                        }else if(Math.abs(p2.y - win.wp1.y) < 8) {
                            return [ { x: p1.x, y: win.wp1.y + len }, { x: p1.x, y: win.wp1.y } ]
                        }
                    }
                }
            }
            if(p1.y == p2.y && win.wp1.y == win.wp2.y && p1.y == win.wp1.y) { // 水平
                if(dir == 'right') { // p1.x < p2.x
                    if(win.wp1.x < win.wp2.x) {
                        if(Math.abs(p1.x - win.wp2.x) < 8) {
                            return [ { x: win.wp2.x, y: p1.y }, { x: win.wp2.x + len, y: p1.y } ]
                        }else if(Math.abs(p2.x - win.wp1.x) < 8) {
                            return [ { x: win.wp1.x - len, y: p1.y }, { x: win.wp1.x, y: p1.y } ]
                        }
                    }else{
                        if(Math.abs(p1.x - win.wp1.x) < 8) {
                            return [ { x: win.wp1.x, y: p1.y }, { x: win.wp1.x + len, y: p1.y } ]
                        }else if(Math.abs(p2.x - win.wp2.x) < 8) {
                            return [ { x: win.wp2.x - len, y: p1.y }, { x: win.wp2.x, y: p1.y } ]
                        }
                    }
                }else if(dir == 'left') { // p1.x > p2.x
                    if(win.wp1.x < win.wp2.x) {
                        if(Math.abs(p2.x - win.wp2.x) < 8) {
                            return [ { x: win.wp2.x + len, y: p1.y }, { x: win.wp2.x, y: p1.y } ]
                        }else if(Math.abs(p1.x - win.wp1.x) < 8) {
                            return [ { x: win.wp1.x, y: p1.y }, { x: win.wp1.x - len, y: p1.y } ]
                        }
                    }else{
                        if(Math.abs(p1.x - win.wp2.x) < 8) {
                            return [ { x: win.wp2.x, y: p1.y }, { x: win.wp1.x - len, y: p1.y } ]
                        }else if(Math.abs(p2.x - win.wp1.x) < 8) {
                            return [ { x: win.wp1.x + len, y: p1.y }, { x: win.wp1.x, y: p1.y } ]
                        }
                    }
                }
            }
        } 
        return []
    }

    function judgeConnectDoor(p1, p2, dir, len) { // 判断是否需要与其他的门连接 参数 dir 表示 p1-p2 的方向
        for(let i = 0;i < doorData.length;i++) {
            let door = doorData[i]
            if(p1.x == p2.x && door.dp1.x == door.dp2.x && p1.x == door.dp1.x) { // 垂直
                if(dir == 'up') { // p1.y < p2.y
                    if(door.dp1.y < door.dp2.y) {
                        if(Math.abs(p2.y - door.dp1.y) < 8) {
                            return [ { x: p1.x, y: door.dp1.y - len }, { x: p1.x, y: door.dp1.y } ]
                        }else if(Math.abs(p1.y - door.dp2.y) < 8) {
                            return [ { x: p1.x, y: door.dp2.y }, { x: p1.x, y: door.dp2.y + len } ]
                        }
                    }else{
                        if(Math.abs(p2.y - door.dp2.y) < 8) {
                            return [ { x: p1.x, y: door.dp2.y - len }, { x: p1.x, y: door.dp2.y } ]
                        }else if(Math.abs(p1.y - door.dp1.y) < 8) {
                            return [ { x: p1.x, y: door.dp1.y }, { x: p1.x, y: door.dp1.y + len } ]
                        }
                    }
                }else if(dir == 'down'){ // p1.y > p2.y
                    if(door.dp1.y < door.dp2.y) {
                        if(Math.abs(p1.y - door.dp1.y) < 8) {
                            return [ { x: p1.x, y: door.dp1.y }, { x: p1.x, y: door.dp1.y - len } ]
                        }else if(Math.abs(p2.y - door.dp2.y) < 8) {
                            return [ { x: p1.x, y: door.dp2.y + len }, { x: p1.x, y: door.dp2.y } ]
                        }
                    }else{
                        if(Math.abs(p1.y - door.dp2.y) < 8) {
                            return [ { x: p1.x, y: door.dp2.y }, { x: p1.x, y: door.dp2.y - len } ]
                        }else if(Math.abs(p2.y - door.dp1.y) < 8) {
                            return [ { x: p1.x, y: door.dp1.y + len }, { x: p1.x, y: door.dp1.y } ]
                        }
                    }
                }
            }
            if(p1.y == p2.y && door.dp1.y == door.dp2.y && p1.y == door.dp1.y) { // 水平
                if(dir == 'right') { // p1.x < p2.x
                    if(door.dp1.x < door.dp2.x) {
                        if(Math.abs(p1.x - door.dp2.x) < 8) {
                            return [ { x: door.dp2.x, y: p1.y }, { x: door.dp2.x + len, y: p1.y } ]
                        }else if(Math.abs(p2.x - door.dp1.x) < 8) {
                            return [ { x: door.dp1.x - len, y: p1.y }, { x: door.dp1.x, y: p1.y } ]
                        }
                    }else{
                        if(Math.abs(p1.x - door.dp1.x) < 8) {
                            return [ { x: door.dp1.x, y: p1.y }, { x: door.dp1.x + len, y: p1.y } ]
                        }else if(Math.abs(p2.x - door.dp2.x) < 8) {
                            return [ { x: door.dp2.x - len, y: p1.y }, { x: door.dp2.x, y: p1.y } ]
                        }
                    }
                }else if(dir == 'left') { // p1.x > p2.x
                    if(door.dp1.x < door.dp2.x) {
                        if(Math.abs(p2.x - door.dp2.x) < 8) {
                            return [ { x: door.dp2.x + len, y: p1.y }, { x: door.dp2.x, y: p1.y } ]
                        }else if(Math.abs(p1.x - door.dp1.x) < 8) {
                            return [ { x: door.dp1.x, y: p1.y }, { x: door.dp1.x - len, y: p1.y } ]
                        }
                    }else{
                        if(Math.abs(p1.x - door.dp2.x) < 8) {
                            return [ { x: door.dp2.x, y: p1.y }, { x: door.dp1.x - len, y: p1.y } ]
                        }else if(Math.abs(p2.x - door.dp1.x) < 8) {
                            return [ { x: door.dp1.x + len, y: p1.y }, { x: door.dp1.x, y: p1.y } ]
                        }
                    }
                }
            }
        }
        return []
    }

    function judgeSideWallDir() { // 判断外墙壁是顺时针还是逆时针 true-顺时针  false-逆时针
        let { p, index } = getSmallestPoint()
        let len = sidewallData.length
        let prePoint = sidewallData[(index-1)<0?(len-1):(index-1)]
        let nextPoint = sidewallData[(index+1)==len?0:(index+1)]
        let s = ((prePoint.x-p.x)*(nextPoint.y-p.y)-(nextPoint.x-p.x)*(prePoint.y-p.y))
        console.log(s<0)
        return s < 0
    }

    function addWinToSideWallData(data) { // 将窗户的数据插入到墙壁的数据结构中 
        
        if(data.parentWall == 'sideWall') {
             if(Math.min(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2)) == 0 && 
            Math.max(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2)) == sidewallData.length -1
            ) {
                sidewallData[0].children.push({
                    type: 'win',
                    start: { x: data.wp1.x, y: data.wp1.y },
                    end: { x: data.wp2.x, y: data.wp2.y }
                })
            }else { // 不是最后的一条线段
                sidewallData[Math.max(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2))].children.push({
                    type: 'win',
                    start: { x: data.wp1.x, y: data.wp1.y },
                    end: { x: data.wp2.x, y: data.wp2.y }
                })
            }
        }else { // insideWall
            for(let i = 0;i < insidewallData.length;i++) {
                let wall = insidewallData[i]
                if(JSON.stringify(data.l1) == JSON.stringify(wall.start) && 
                JSON.stringify(data.l2) == JSON.stringify(wall.end)){
                    wall.children.push({ // 正面的窗户
                        type: 'win',
                        start: { x: data.wp1.x, y: data.wp1.y },
                        end: { x: data.wp2.x, y: data.wp2.y }
                    })
                }
            }
            for(let i = 0;i < insidewallData.length;i++) {
                let wall = insidewallData[i]
                if(JSON.stringify(data.l1) == JSON.stringify(wall.end) && 
                JSON.stringify(data.l2) == JSON.stringify(wall.start)){
                    wall.children.push({ // 反面的窗户
                        type: 'win',
                        start: { x: data.wp2.x, y: data.wp2.y },
                        end: { x: data.wp1.x, y: data.wp1.y }
                    })
                }
            }
        }
       
    }

    function addDoorToSideWallData(data) {// 将门的数据插入到墙壁的数据结构中
        if(data.parentWall == 'sideWall') { // 插入到外墙壁
            if(Math.min(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2)) == 0 && 
            Math.max(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2)) == sidewallData.length -1
            ) {
                sidewallData[0].children.push({
                    type: 'door',
                    start: { x: data.dp1.x, y: data.dp1.y },
                    end: { x: data.dp2.x, y: data.dp2.y }
                })
            }else { // 不是最后的一条线段
                sidewallData[Math.max(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2))].children.push({
                    type: 'door',
                    start: { x: data.dp1.x, y: data.dp1.y },
                    end: { x: data.dp2.x, y: data.dp2.y }
                })
            }
        }else { // insideWall 插入到内墙壁
            for(let i = 0;i < insidewallData.length;i++) {
                let wall = insidewallData[i]
                if(JSON.stringify(data.l1) == JSON.stringify(wall.start) && 
                JSON.stringify(data.l2) == JSON.stringify(wall.end)){
                    wall.children.push({ // 正面的门
                        type: 'door',
                        start: { x: data.dp1.x, y: data.dp1.y },
                        end: { x: data.dp2.x, y: data.dp2.y }
                    })
                }
            }
            for(let i = 0;i < insidewallData.length;i++) {
                let wall = insidewallData[i]
                if(JSON.stringify(data.l1) == JSON.stringify(wall.end) && 
                JSON.stringify(data.l2) == JSON.stringify(wall.start)){

                    wall.children.push({ // 反面的门
                        type: 'door',
                        start: { x: data.dp2.x, y: data.dp2.y },
                        end: { x: data.dp1.x, y: data.dp1.y }
                    })
                }
            }
        }
       
    }

    function getInsideWallRotation(insidewall) { // 获取内墙壁对象的旋转角度
        let start = insidewall.start
        let end = insidewall.end
        if(start.x < end.x && start.y == end.y) { // 右
            return 0
        }else if(start.x == end.x && start.y < end.y) { // 下
            return -Math.PI / 2
        }else if(start.x > end.x && start.y == end.y) { // 左
            return -Math.PI
        }else if(start.x == end.x && start.y > end.y) { // 上
            return -3*Math.PI/2
        }
    }

    function getPointRotation(startPoint, endPoint) { // 判断一条线段的旋转角度 (判断的线段已经经过直角调整)
        if(endPoint.x >= startPoint.x && endPoint.y == startPoint.y) {      // 右
            return 0
        }else if(endPoint.x == startPoint.x && endPoint.y >= startPoint.y) {// 下
            return -Math.PI / 2
        }else if(endPoint.x < startPoint.x && endPoint.y == startPoint.y) { // 左
            return -Math.PI
        }else if(endPoint.x == startPoint.x && endPoint.y < startPoint.y) { // 上
            return -3*Math.PI/2
        }
    }

    function adjustLastPointPos() { // 调整最后一个点的位置，以适应直角
        let lastPoint = sidewallData[sidewallData.length - 1]
        let firstPoint = sidewallData[0]
        let p = { x: lastPoint.x, y: lastPoint.y }
       
        if(sidewallData[0].x == sidewallData[1].x) {        // 起始线段垂直
            p.y = firstPoint.y
        }else if(sidewallData[0].y == sidewallData[1].y){   // 起始线段水平
            p.x = firstPoint.x
        }
        return p
    }

    function adjustPointPos(lastPoint, currentPoint) { // 调整绘制点的位置 （主要是控制直角墙面， 暂时不考虑斜角）
        let distance = pointsDistance(lastPoint, currentPoint)
        let xLen = Math.abs(currentPoint.x - lastPoint.x)
        let yLen = Math.abs(currentPoint.y - lastPoint.y)

        if(currentPoint.x >= lastPoint.x && currentPoint.y >= lastPoint.y) {        // 右上
            if(xLen > yLen) {
                return { x: lastPoint.x + distance, y: lastPoint.y }
            }else {
                return { x: lastPoint.x, y: lastPoint.y + distance }
            }
        }else if(currentPoint.x >= lastPoint.x && currentPoint.y < lastPoint.y){    // 右下
            if(xLen > yLen) {
                return { x: lastPoint.x + distance, y: lastPoint.y }
            }else {
                return { x: lastPoint.x, y: lastPoint.y - distance }
            }
        }else if(currentPoint.x < lastPoint.x && currentPoint.y <= lastPoint.y){    // 左下
            if(xLen > yLen) {
                return { x: lastPoint.x - distance, y: lastPoint.y }
            }else {
                return { x: lastPoint.x, y: lastPoint.y - distance }
            }
        }else if(currentPoint.x < lastPoint.x && currentPoint.y > lastPoint.y){     // 左上
            if(xLen > yLen) {
                return { x: lastPoint.x - distance, y: lastPoint.y }
            }else {
                return { x: lastPoint.x, y: lastPoint.y + distance }
            }
        }
    }

    function isNewInSideWallUseful(p1, p2) { // 判断新增内墙是否有效 主要是判断新增内墙是否与现有墙壁相交
        
        if(!isNewSideWallUseful(p1, p2, sidewallData)) return false // 当前内墙会与外墙相交

        for(let i = 0;i < insidewallData.length;i++) { // 判断是否与内墙有相交
            let item = insidewallData[i]
            
            if(isLineIntersect(p1, p2, item.start, item.end)) return false
        }
        
        return true // 没有相交
    }

    function isNewSideWallUseful(p1, p2, points) { // 判断新增外墙是否有效 主要是判断新增外墙是否与现有外墙相交
        for(let i = 0;i < points.length - 1;i++) {
            if(isLineIntersect(p1, p2, points[i], points[i+1])) {
                // console.log('corss')
                return false
            }
        }
        if(isLineIntersect(p1, p2, points[points.length - 1], points[0])) {
            return false
        }
        // console.log('no-cross')
        return true
    }

    function isPointInShape(pt, poly) { // 判断传入的点是否在外墙图形的内部
        for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) 
            ((poly[i].y <= pt.y && pt.y < poly[j].y) || (poly[j].y <= pt.y && pt.y < poly[i].y)) 
            && (pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) 
            && (c = !c); 
        return c; 
    }

    function isLineIntersect(p1, p2, p3, p4) { // 判断线段 p1-p2 与线段 p3-p4 是否相交 用于检测用户新增的点是否有效
        
        if((p1.x == p2.x && p3.y == p4.y)) {
           
            if(Math.max(p1.y, p2.y) > p3.y && 
            Math.min(p1.y, p2.y) < p3.y &&
            Math.max(p3.x, p4.x) > p1.x &&
            Math.min(p3.x, p4.x) < p1.x
            ) {
                return true // cross
            }
            return false // no-cross
        }else if(p1.y == p2.y && p3.x == p4.x) {
            if(Math.max(p1.x, p2.x) > p3.x && 
            Math.min(p1.x, p2.x) < p3.x &&
            Math.max(p3.y, p4.y) > p1.y &&
            Math.min(p3.y, p4.y) < p1.y
            ) {
                return true // cross
            }
            return false // no-cross
        }else if(p1.x == p2.x && p3.x == p4.x) {
           
            if(p1.x == p3.x &&
                (Math.max(p1.y, p2.y, p3.y, p4.y) - Math.min(p1.y, p2.y, p3.y, p4.y)) < 
                (Math.abs(p1.y - p2.y) + Math.abs(p3.y - p4.y))
            ){
                return true
            }
            return false
        }else if(p1.y == p2.y && p3.y == p4.y) {
            
            if(p1.y == p3.y &&
                (Math.max(p1.x, p2.x, p3.x, p4.x) - Math.min(p1.x, p2.x, p3.x, p4.x)) < 
                (Math.abs(p1.x - p2.x) + Math.abs(p3.x - p4.x))
            ){
                return true
            }
            return false
        }
    }

    function isEven(n) { // 判断传入的数值是否是偶数
        return n%2 === 0
    }

    function isSelectPoint(p) { // 判断点击的位置是否选中了墙壁的一个点
        for(let i = 0;i < sidewallData.length;i++) { // 外墙的点
            if(pointsDistance(p, sidewallData[i]) < 8) {
                return { x: sidewallData[i].x, y: sidewallData[i].y }
            }
        }

        for(let i = 0;i < insidewallData.length;i++) { // 内墙的点
            if(pointsDistance(p, insidewallData[i].start) < 8) {
                return { x: insidewallData[i].start.x, y: insidewallData[i].start.y }
            }

            if(pointsDistance(p, insidewallData[i].end) < 8) {
                return { x: insidewallData[i].end.x, y: insidewallData[i].end.y }
            }
        }

        return null // 用户没有选中墙壁的边界点
    }

    function isSelectInSideWall(p) { // 根据传入的点击点位判断拥有有没有选中内墙
        for(let i = 0;i < insidewallData.length;i++) {
            let l1 = insidewallData[i].start
            let l2 = insidewallData[i].end
            let dis = pointToLine(p, l1, l2)
            if(dis < 4) return [p, l1, l2]
        }
        return []
    }

    function isSelectSideWall(p) { // 根据传入的点击点位判断拥有有没有选中外墙 
        for(let i = 0;i < sidewallData.length;i++) { // 与当前外墙的每一条线段做对比
            if(i < sidewallData.length - 1) { // 不是最后一个点
                let l1 = sidewallData[i]
                let l2 = sidewallData[i+1]
                let dis = pointToLine(p, l1, l2)
                if(dis < 4) {
                    return [p, l1, l2]
                }
            }else { // 最后一个点
                let l1 = sidewallData[i]
                let l2 = sidewallData[0]
                let dis = pointToLine(p, l1, l2)
                if(dis < 4) {
                    return [p, l1, l2]
                }
            }
        }
        return []
    }

    function getInLinePoint(p, l1, l2) { // 判断点 p 到线段 l1-l2 的垂足 (l1-l2 线段水平或垂直)
        if(l1.y == l2.y) { // l1-l2 水平
            return { x: p.x, y: l1.y }
        }else { // l1-l2 垂直
            return { x: l1.x, y: p.y }
        }
    }

    function getSmallestPoint() { // 获取外墙壁中最靠近原点的节点 （最靠近左上角）
        let p = sidewallData[0], index = 0
        for(let i = 1;i < sidewallData.length;i++) {
            if(sidewallData[i].x < p.x || sidewallData[i].y < p.y) {
                p = sidewallData[i]
                index = i
            }
        }
        return { p, index } // 返回最小的节点和该节点在外墙壁节点列表中的位置 
    }

    function pointToLine(p, l1, l2) { // 判断点 p 到线段 l1-l2 的距离 (l1-l2 线段水平或垂直)
        if(l1.y == l2.y) { // l1-l2 水平
            if(p.x > Math.max(l1.x, l2.x) || p.x < Math.min(l1.x, l2.x)) { // 过滤非范围内的点
                return 100
            }
            return Math.abs(p.y - l1.y)
        }else { // l1-l2 垂直
            if(p.y > Math.max(l1.y, l2.y) || p.y < Math.min(l1.y, l2.y)) { // 过滤非范围内的点
                return 100
            }
            return Math.abs(p.x - l1.x)
        }
    }
 
    function pointsDistance(p1, p2) { // 返回两点之间的距离
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2))
    }
    
    function initBgGrid() { // 初始化背景的网格线
        // 背景的宽高是包围框的两倍
        let bgcanvas = document.getElementById('bgplane') 
        let bgwidth = bgcanvas.clientWidth*2
        let bgheight = bgcanvas.clientHeight*2
        bgcanvas.width = bgwidth
        bgcanvas.height = bgheight
        bgctx = bgcanvas.getContext('2d')
        drawBgGrid(bgctx, bgwidth, bgheight)
    }

    function drawBgGrid( bgctx, bgwidth, bgheight) { // 绘制背景的网格线
        bgctx.globalAlpha = 0.3
        let widthCount = grid_widthCount, widthLen = bgwidth / widthCount
        let heightCount = grid_heightCout, heightLen = bgheight / heightCount

        for(let i = 0;i < widthCount;i++) { // 横线
            drawLine(bgctx, { x: widthLen * i, y: 0 }, { x: widthLen * i, y: bgheight } )
        }

        for(let j = 0;j < heightCount;j++) { // 竖线
            drawLine(bgctx, { x: 0, y: heightLen * j }, { x: bgwidth, y: heightLen * j } )
        }
        bgctx.globalAlpha = 1
    }

    function combineData() { // 将窗户、门的数据合并到外墙壁和内墙壁的数据结构中
        for(let i = 0;i < winData.length;i++) {
            addWinToSideWallData(winData[i])
        }
        for(let i = 0;i < doorData.length;i++) {
            addDoorToSideWallData(doorData[i])
        }
    }

    function outData() { // 输出当前制图的数据
        combineData()
        let sideData = transformSideWall()
        let insideData = transformInSideWall()
        let groundData = transformGround()
        judgeSideWallDir()
        // console.log(JSON.stringify([...sideData]))
        // console.log(sideData)
        // console.log(JSON.stringify([...groundData]))
        // console.log(JSON.stringify([...insideData]))
        // console.log(insideData)
        // console.log(JSON.stringify([...sideData, ...groundData]))
        console.log(JSON.stringify([...sideData, ...groundData, ...insideData]))
        // console.log(JSON.stringify(insidewallData))
    }

    function changeType(type) { // 改变当前正在绘制的墙壁的类型
        let title = document.getElementById('currentType')
        title.innerText = type
        type = type
        currentType.type = type
        drawCanvas.removeEventListener('mousemove', handleMove)
        if(type == 'win' || type == 'door') {
            drawCanvas.addEventListener('mousemove', handleMove)
        }
    }

    function transformSideWall() { // 根据现有数据生成外墙中间数据 {// wall1
        let xArr = [], yArr = []
        for(let i = 0;i < sidewallData.length;i++) {
            xArr.push(sidewallData[i].x)
            yArr.push(sidewallData[i].y)
        }
        let minX = Math.min(...xArr)
        let minY = Math.min(...yArr)
        let sidewall = []
        let r = 0
      
    
        for(let i = 0;i < sidewallData.length;i++) {
            if(i < sidewallData.length - 1) { // 不是最后一个点
                let current = sidewallData[i]
                let next = sidewallData[i+1]
                let childArr = []
                for(let j = 0;j < next.children.length;j++) {
                    let p = next.children[j]
                    childArr.push({
                        type: p.type,
                        start: { x: p.start.x - minX, y: p.start.y - minY},
                        end: { x: p.end.x - minX, y: p.end.y - minY}
                    })
                }
                sidewall.push({
                    type: 'sideWall',
                    start: { x: current.x - minX, y: current.y - minY },
                    end: { x: next.x - minX, y: next.y - minY},
                    children: childArr,
                    rotation: next.rotation
                })
            }else { // 最后一个点
                let current = sidewallData[i]
                let next = sidewallData[0]
                let childArr = []
                for(let j = 0;j < next.children.length;j++) {
                    let p = next.children[j]
                    childArr.push({
                        type: p.type,
                        start: { x: p.start.x - minX, y: p.start.y - minY },
                        end: { x: p.end.x - minX, y: p.end.y - minY }
                    })
                    
                }
                sidewall.push({
                    type: 'sideWall',
                    start: { x: current.x - minX, y: current.y - minY },
                    end: { x: next.x - minX, y: next.y - minY },
                    children: childArr,
                    rotation: next.rotation
                })
            }
        }
      
        return transformWalls(sidewall)
    }

    function transformInSideWall() { //  根据现有数据生成内墙中间数据
        let xArr = [], yArr = []
        for(let i = 0;i < sidewallData.length;i++) {
            xArr.push(sidewallData[i].x)
            yArr.push(sidewallData[i].y)
        }
        let minX = Math.min(...xArr)
        let minY = Math.min(...yArr)
        let insidewall = []
        for(let i = 0;i < insidewallData.length;i++) {
                let current = insidewallData[i]
                let childArr = []
                for(let j = 0;j < current.children.length;j++) {
                    let p = current.children[j]
                    childArr.push({
                        type: p.type,
                        start: { x: p.start.x - minX, y: p.start.y - minY },
                        end: { x: p.end.x - minX, y: p.end.y - minY }
                    })
                }
                insidewall.push({
                    type: 'insideWall',
                    start: { x: current.start.x - minX, y: current.start.y - minY },
                    end: { x: current.end.x - minX, y: current.end.y - minY },
                    children: childArr,
                    rotation: current.rotation
                })
        }
        // console.log(insidewall)
        return transformWalls(insidewall)
    }

    function transformGround() { //  根据现有数据生成地面和天花板中间数据
        let xArr = [], yArr = []
        for(let i = 0;i < sidewallData.length;i++) {
            xArr.push(sidewallData[i].x)
            yArr.push(sidewallData[i].y)
        }
        let minX = Math.min(...xArr)
        let minY = Math.min(...yArr)

        let groundwall = []
        for(let i = 0;i < sidewallData.length;i++) {
            if(i < sidewallData.length - 1) { // 不是最后一个点
                let current = sidewallData[i]
                let next = sidewallData[i+1]
                groundwall.push({
                    type: 'sideWall',
                    start: { x: current.x - minX, y: current.y - minY },
                    end: { x: next.x - minX, y: next.y - minY },
                    children: [],
                    rotation: next.rotation
                })
            }else { // 最后一个点
                let current = sidewallData[i]
                let next = sidewallData[0]
                groundwall.push({
                    type: 'sideWall',
                    start: { x: current.x - minX, y: current.y - minY },
                    end: { x: next.x - minX, y: next.y - minY },
                    children: [],
                    rotation: next.rotation
                })
            }
        }

        let fpoints = []
        let rpoints = []
        for(let i = 0;i < groundwall.length;i++) {
            fpoints.push({ x: groundwall[i].start.x, y: groundwall[i].start.y * -1 })
            rpoints.push({ x: groundwall[i].start.x * -1, y: groundwall[i].start.y * -1 })
        }
        fpoints.push({ x: groundwall[0].start.x, y: groundwall[0].start.y * -1 })
        rpoints.push({ x: groundwall[0].start.x * -1, y: groundwall[0].start.y * -1 })
        return [
            {
                type: 'floor',      // 地面
                children: [],
                start: fpoints[0],
                path: fpoints,
                position: { x: 0, y: 0, z: 0},
                rotation: { x: -Math.PI/2, y: 0 }
            },
            {
                type: 'roof',    
                children: [],
                start: rpoints[0],
                path: rpoints,
                position: { x: 0, y: 30, z: 0},
                rotation: { x: -Math.PI/2, y: Math.PI }
            }
        ]

    }

    function transformWalls(walls) { // 将墙壁数值的中间数据结构二次转换
        let data = []
        for(let i = 0;i < walls.length;i++) {
                let wall = walls[i], children = []
                let len = Math.sqrt(Math.pow(wall.start.x - wall.end.x, 2) + Math.pow(wall.start.y - wall.end.y, 2))
                for(let j = 0;j < wall.children.length; j++) {
                    let item = {}, child = wall.children[j]
                    item.type = child.type
                    let startX =  Math.sqrt(Math.pow(wall.start.x - child.start.x, 2) + Math.pow(wall.start.y - child.start.y, 2))
                    item.start = { x: startX, y: 10 }
                    let childLen = Math.sqrt(Math.pow(child.start.x - child.end.x, 2) + Math.pow(child.start.y - child.end.y, 2))
                    item.path = [
                        { x: startX, y: 20 },
                        { x: startX + childLen, y: 20 },
                        { x: startX + childLen, y: child.type=='win'?10:0 },
                        { x: startX, y: child.type=='win'?10:0 }
                    ]
                    children.push(item)
                }
                data.push({
                    type: wall.type,
                    children, 
                    start: { x: 0, y: 0 },
                    path: [
                        { x: 0, y: 30 },
                        { x: len, y: 30 },
                        { x: len, y: 0 },
                        { x: 0, y: 0 }
                    ],
                    position: { x: wall.start.x, y: 0, z: wall.start.y },
                    rotation: { x: 0, y: wall.rotation }
                })
            } 
            return data
    }

    function reset() { // 重新设置画布大小
        wrap = document.getElementById('canWrap')
        wrapWidth = wrap.clientWidth
        wrapHeight = wrap.clientHeight // 画布基准大小
    }
</script>
</html>