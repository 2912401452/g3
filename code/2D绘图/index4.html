<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        html{
            height: 100%;
        }
        body{
            margin: 0;
            height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #ffff00;
        }
        #leftWrap, #rightWrap{
            width: 20vw;
            height: 40vw;
            background-color: aqua;
        }
        #canWrap {
            position: relative;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
            width: 60vw;
            height: 40vw;
            background-color: #fff;
        }
        #canWrap .can{
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }
        .btn{
            border: 1px solid #0000ff;
            padding: 5px;
            cursor: pointer;
        }
        .btn:hover{
            background-color: aquamarine;
        }
        #currentType {
            position: absolute;
            top: 0;
            display: block;
            text-align: center;
        }
    </style>
</head>
<body>
    <h3 id="currentType">sidewall</h3>
    <div id="leftWrap">
        <div class="btn" onclick="changeType('sidewall')">sidewall</div>
        <div class="btn" onclick="changeType('insidewall')">insidewall</div>
        <div class="btn" onclick="changeType('win')">win</div>
        <div class="btn" onclick="changeType('door')">door</div>
        <div class="btn" onclick="outData()" style="background-color: red">out data</div>
    </div>
    <div id="canWrap">
        <canvas id="bgplane" class="can"></canvas>
        <canvas id="drawplane" class="can"></canvas>
    </div>
    <div id="rightWrap">
        <div class="btn" onclick="freshCanvas()">fresh</div>
    </div>
</body>
<script>
    let grid_widthCount = 90 // 背景网格线水平格数
    let grid_heightCout = 60 // 背景网格线垂直格数
    let grid_wid_len = null  // 背景网格线水平格宽度
    let grid_hei_len = null  // 背景网格线水平格高度
    let WIDTH = 600, HEIGHT = 400 // 设置整个画布可以容纳的刻度大小
    let wrap = document.getElementById('canWrap')
    let wrapWidth = wrap.clientWidth
    let wrapHeight = wrap.clientHeight // 画布基准大小

    let drawCtx, bgctx // 上下文对象
    let drawCanvas = document.getElementById('drawplane')

    let isSideFinished = false      // 用于标记用户的外墙绘制是否结束
    let isInSideFinished = false    // 用于标记用户的内墙绘制是否结束

    let type = 'sidewall' // sidewall - insidewall - win - door
    let currentType = {
        type: 'sidewall'
    }

    let currentWin = null // 当前的窗户
    let currentDoor = null// 当前的门

    let sidewallData = [] // 记录绘画的点的位置 x - y - type
    let insidewallData = [] // x - y - type - inline(l1.x l1.y - l2.x l2.y)
    let insideWallItem = null // 内墙壁的数据是一段一段记录的，所以需要一个变量来保存一段墙壁的起点
    let winData = []    // 存放窗户的信息 主要用于canvas的绘图用
    // { wp1: p, wp2: {x: p.x, y: p.y + len}, l1, l2 }
    let doorData = []   // 存放门的信息  主要用于canvas的绘图用
    // { dp1: p, dp2: {x: p.x, y: p.y + len}, l1, l2 }

    initBgGrid() // 初始化背景网格线
    initDrawConfig()

    window.addEventListener('resize', reset)
    
    function initDrawConfig() { // 初始化绘制画布的一些配置
        
        let drawwidth = drawCanvas.clientWidth
        let drawheight = drawCanvas.clientHeight
        drawCanvas.width = drawwidth
        drawCanvas.height = drawheight
        drawCtx = drawCanvas.getContext('2d')

        drawCanvas.addEventListener('click', handleClick) 
        drawCanvas.addEventListener('mouseup', handleUp)
    }

    function handleClick(e) { // 鼠标点击时做的动作
        
        let plane = e.target
        let { x, y } = plane.getBoundingClientRect()
        let px = e.clientX - x
        let py = e.clientY - y 
       
        if(currentType.type == 'sidewall') { // 当前绘制外墙
            if(isSideFinished) return
            let lastPoint = sidewallData[sidewallData.length - 1]
            if(sidewallData.length > 0) { // 除了第一个点之外，在绘制其他的点的时候都需要对点的位置进行矫正
                let standedPoint = adjustPointPos(lastPoint, { x: px, y: py})
                standedPoint.type = 'sidewall'
                standedPoint.rotation = getPointRotation(lastPoint, standedPoint)
                standedPoint.children = []
                // isNewSideWallUseful(lastPoint, standedPoint, sidewallData)
                if(isNewSideWallUseful(lastPoint, standedPoint, sidewallData)) { // 当前新增点有效
                    sidewallData.push(standedPoint) // 加点
                }
                // sidewallData.push(standedPoint) // 加点
            }else{
                sidewallData.push({ // 加点（第一个点，第一个点的rotation在加最后一个点的时候赋值）
                    x: px,
                    y: py,
                    type: currentType.type,
                    children: []
                })
            }
            drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
            drawDataToScreen()

        }else if(currentType.type == 'insidewall') { // 当前绘制内墙

            if(!isSideFinished) return // 只有在外墙完成绘制后才能绘制内墙
            let selectWallResult = isSelectSideWall({x: px, y: py}) // 先判断用户有没有选中外墙
            if(selectWallResult.length == 0) selectWallResult = isSelectInSideWall({x: px, y: py}) // 再判断用户有没有选中内墙
            let selectedPointResult = isSelectPoint({ x: px, y: py })
            
            if(selectedPointResult !== null) { // 用户选中了现有墙壁的节点
                if(insideWallItem !== null) { // 用户在完成绘制一段内墙壁时选择的第二个点也在
                    // if(pointsDistance(insideWallItem.start, { x: selectedPointResult.x, y: selectedPointResult.y }) > 8){ // 没有再次选中当前内墙壁的起始点时取消当前内墙壁的绘制
                    //     console.log(selectedPointResult)
                    // }
                    insideWallItem = null
                }else {
                    insideWallItem = {
                        start: { x: selectedPointResult.x, y: selectedPointResult.y },
                        end: {}
                    }
                }
            }else {
                if(selectWallResult.length > 0) { // 当前用户选中了一段墙
                 
                    let insidePoint = getInLinePoint(...selectWallResult) // 选中墙的垂足
                    if(insideWallItem !== null) { // 这一段内墙壁已经选中一个点 且再次选中的点在墙壁上
                    
                        let standedPoint = adjustPointPos(insideWallItem.start, { x: insidePoint.x, y: insidePoint.y}) // 调整后的点
                        // console.log(pointsDistance(insideWallItem.start, { x: standedPoint.x, y: standedPoint.y }))
                        if(pointsDistance(insideWallItem.start, { x: standedPoint.x, y: standedPoint.y }) > 8){ // 没有再次选中当前内墙壁的起始点时取消当前内墙壁的绘制
                            // console.log(isNewInSideWallUseful(insideWallItem.start, standedPoint))
                            
                            // if(isNewInSideWallUseful(insideWallItem.start, standedPoint)) {
                                insideWallItem.end = { x: standedPoint.x, y: standedPoint.y }
                                insidewallData.push({ // 正面的内墙壁
                                    start: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                    end: { x: standedPoint.x, y: standedPoint.y },
                                    children: [],
                                    rotation: getInsideWallRotation(insideWallItem)
                                })
                                insidewallData.push({ // 反面的内墙壁 用户在将绘制的数据转化时会同时多输入一遍数据
                                    end: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                    start: { x: standedPoint.x, y: standedPoint.y },
                                    children: [],
                                    rotation: getInsideWallRotation({
                                        end: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                        start: { x: standedPoint.x, y: standedPoint.y }
                                    })
                                })
                            // }
                        
                        }
                        insideWallItem = null
                    }else { // 这一段内墙壁刚刚开始确定第一个点
                        insideWallItem = {
                            start: { x: insidePoint.x, y: insidePoint.y },
                            end: {}
                        }
                    }
                }else if(isPointInShape({ x: px, y: py }, sidewallData)){ // 用户点击了房间的内部
                    
                    if(insideWallItem !== null) { // 这一段内墙壁已经选中一个点
                        
                        let standedPoint = adjustPointPos(insideWallItem.start, { x: px, y: py})
                       
                        // console.log(isNewInSideWallUseful(insideWallItem.start, standedPoint))
                        if(pointsDistance(insideWallItem.start, { x: standedPoint.x, y: standedPoint.y }) > 8){ // 没有再次选中当前内墙壁的起始点时取消当前内墙壁的绘制
                            
                            if(isNewInSideWallUseful(insideWallItem.start, standedPoint)) {
                                insideWallItem.end = { x: standedPoint.x, y: standedPoint.y }
                                insidewallData.push({
                                    start: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                    end: { x: standedPoint.x, y: standedPoint.y },
                                    children: [],
                                    rotation: getInsideWallRotation(insideWallItem)
                                })
                                insidewallData.push({
                                    end: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                    start: { x: standedPoint.x, y: standedPoint.y },
                                    children: [],
                                    rotation: getInsideWallRotation({
                                        end: { x: insideWallItem.start.x, y: insideWallItem.start.y },
                                        start: { x: standedPoint.x, y: standedPoint.y }
                                    })
                                })
                            }
                            
                        }
                        insideWallItem = null
                    }else { // 这一段内墙壁刚刚开始确定第一个点
                        insideWallItem = {
                            start: { x: px, y: py },
                            end: {}
                        }
                    }
                }
            }
            
            let lastPoint = sidewallData[sidewallData.length - 1]
            let firstPoint = sidewallData[0]
            drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
            drawDataToScreen()
            drawLine(drawCtx, lastPoint, firstPoint)
        }else if(currentType.type == 'win'){
            if(!isSideFinished) return // 只有在外墙完成绘制后才能绘制窗户
            if(currentWin !== null) {
                winData.push(currentWin)
                addWinToSideWallData(currentWin)
                currentWin = null
            }
        }else if(currentType.type == 'door'){
            if(!isSideFinished) return // 只有在外墙完成绘制后才能绘制窗户
            if(currentDoor !== null) {
                doorData.push(currentDoor)
                addDoorToSideWallData(currentDoor)
                currentDoor = null
            }
        }
        
        drawCanvas.addEventListener('mousemove', handleMove)
    }

    function handleMove(me) { // 在鼠标移动时做的动作
        let plane = me.target
        let { x, y } = plane.getBoundingClientRect()
        let mx = me.clientX - x
        let my = me.clientY - y 

        if(currentType.type == 'sidewall') { // 当前绘制外墙
            let lastPoint = sidewallData[sidewallData.length - 1]
            drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
            drawDataToScreen()
            drawLine(drawCtx, { x: mx, y: my }, { x: lastPoint.x, y: lastPoint.y })
            drawPoint(drawCtx, mx, my, true) // 鼠标移动处的红色标记
            if(sidewallData.length > 2 && pointsDistance(sidewallData[0], { x: mx, y: my }) < 16) {
                let helpPoint = adjustLastPointPos()
                drawLine(drawCtx, helpPoint, lastPoint, '#0000ff')
                drawLine(drawCtx, helpPoint, sidewallData[0], '#0000ff')
            }else if(sidewallData.length > 0) {
                let standedPoint = adjustPointPos(lastPoint, { x: mx, y: my })
                drawLine(drawCtx, standedPoint, lastPoint, '#0000ff')
            }
        }else if(currentType.type == 'insidewall') { // 当在绘制内墙壁时移动鼠标
            if(insideWallItem !== null) {
                let lastPoint = sidewallData[sidewallData.length - 1]
                let firstPoint = sidewallData[0]
                drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
                drawDataToScreen()
                drawLine(drawCtx, firstPoint, lastPoint)
                drawPoint(drawCtx, insideWallItem.start.x, insideWallItem.start.y) // 当前内墙壁的起点
                let standedPoint = adjustPointPos(insideWallItem.start, { x: mx, y: my })
                if(isNewInSideWallUseful(insideWallItem.start, standedPoint)){
                    drawLine(drawCtx, insideWallItem.start, { x: mx, y: my }) // 辅助链接线
                    drawPoint(drawCtx, mx, my, true) // 鼠标移动处的红色标记
                    drawLine(drawCtx, standedPoint, insideWallItem.start, '#0000ff')
                }
                // drawLine(drawCtx, insideWallItem.start, { x: mx, y: my }) // 辅助链接线
                // drawPoint(drawCtx, mx, my, true) // 鼠标移动处的红色标记
                // drawLine(drawCtx, standedPoint, insideWallItem.start, '#0000ff')
            }
        }else if(currentType.type == 'win') { // 当前绘制窗户
            if(!isSideFinished) return // 只有在外墙完成绘制后才能绘制窗户
           
            let result = isSelectSideWall({x: mx, y: my})
            let parentWall = 'sideWall'
            if(result.length == 0){
                parentWall = 'insideWall'
                result = isSelectInSideWall({x: mx, y: my})
            }
            
            if(result.length > 0) { // 当前用户选中了一条外墙线段
                drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
                drawDataToScreen()
                drawLine(drawCtx, sidewallData[0], sidewallData[sidewallData.length - 1])
                let insidePoint = getInLinePoint(...result)
                drawWin({x: insidePoint.x, y: insidePoint.y}, result[1], result[2], parentWall)
            }else {
                currentWin = null
                drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
                drawDataToScreen()
                drawLine(drawCtx, sidewallData[0], sidewallData[sidewallData.length - 1])
            }
           
        }else if(currentType.type == 'door') { // 当前绘制门
            
            if(!isSideFinished) return // 只有在外墙完成绘制后才能绘制门
            let parentWall = 'sideWall'
            let result = isSelectSideWall({x: mx, y: my})
            if(result.length == 0) {
                parentWall = 'insideWall'
                result = isSelectInSideWall({x: mx, y: my})
            }
            if(result.length > 0) { // 当前用户选中了一条外墙线段
                drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
                drawDataToScreen()
                drawLine(drawCtx, sidewallData[0], sidewallData[sidewallData.length - 1])
                let insidePoint = getInLinePoint(...result)
                drawDoor({x: insidePoint.x, y: insidePoint.y}, result[1], result[2], parentWall)
            }else {
                currentDoor = null
                drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
                drawDataToScreen()
                drawLine(drawCtx, sidewallData[0], sidewallData[sidewallData.length - 1])
            }
        }
     
    }

    function handleUp(ue) { // 在鼠标抬起时做的动作
        let plane = ue.target
        let { x, y } = plane.getBoundingClientRect()
        let ux = ue.clientX - x
        let uy = ue.clientY - y 

        if(currentType.type == 'sidewall') { // 当前绘制外墙
            let lastPoint = sidewallData[sidewallData.length - 1]
            let firstPoint = sidewallData[0]
            if(sidewallData.length > 0 && pointsDistance(lastPoint, { x: ux, y: uy }) < 16) { // 用户重复点击 
                if(!isSideFinished) { // 执行退出当前编辑状态
                    drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
                    drawDataToScreen()
                    isSideFinished = true
                }else { //  重新进入当前编辑状态
                    sidewallData.pop()
                    isSideFinished = false
                }
            }
            if(sidewallData.length > 2 && pointsDistance(firstPoint, { x: ux, y: uy }) < 16) { // 至少已经存在三个点 最少四个点构成一个房间
                let p = adjustLastPointPos()
                if(!isEven(sidewallData.length)) {
                    sidewallData.push({
                        type: 'sideWall',
                        x: p.x,
                        y: p.y,
                        rotation: getPointRotation(lastPoint, { x: p.x, y: p.y }),
                        children: []
                    })
                    lastPoint = sidewallData[sidewallData.length - 1]
                }
                lastPoint.x = p.x
                lastPoint.y = p.y
                firstPoint.rotation = getPointRotation(lastPoint, firstPoint)
                drawCtx.clearRect( 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight )
                drawDataToScreen()
                drawLine(drawCtx, lastPoint, firstPoint)
                isSideFinished = true
            }
        }else if(currentType.type == 'insidewall') {
           
        }

        drawCanvas.removeEventListener('mousemove', handleMove)
    }

    function freshCanvas() { // 刷新画布
        sidewallData = []
        insidewallData = []
        winData = []
        doorData = []
        isSideFinished = false
        currentWin = null
        insideWallItem = null
        changeType('sidewall')
        drawCtx.clearRect(0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight)
    }

    function drawDataToScreen() { // 将数据中的点画到画布上 
        drawSideWallToScreen()
        drawInSideWallToScreen()
        drawWinToScreen()
        drawDoorToScreen()
    }

    function drawWinToScreen() { // 将窗户画到画布
        for(let i = 0;i < winData.length;i++) {
            let win = winData[i]
            drawPoint(drawCtx, win.wp1.x, win.wp1.y, false, '#0000ff')
            drawLine(drawCtx, win.wp1, win.wp2, '#0000ff')
            drawPoint(drawCtx, win.wp2.x, win.wp2.y, false, '#0000ff')
        }
    }

    function drawDoorToScreen() { // 将门画到画布
        for(let i = 0;i < doorData.length;i++) {
            let door = doorData[i]
            drawPoint(drawCtx, door.dp1.x, door.dp1.y, false, '#00ff00')
            drawLine(drawCtx, door.dp1, door.dp2, '#00ff00')
            drawPoint(drawCtx, door.dp2.x, door.dp2.y, false, '#00ff00')
        }
    }

    function drawSideWallToScreen() { // 将外墙画到屏幕上
        for(let i = 0;i < sidewallData.length;i++) {
            let point = sidewallData[i]
            let nextPoint = sidewallData[i+1]
            drawPoint(drawCtx, point.x, point.y)
            if(nextPoint !== undefined) { // 当存在下一个顶点的时候
                drawLine(drawCtx, { x: point.x, y: point.y }, { x: nextPoint.x, y: nextPoint.y })
            }
        }
    }

    function drawInSideWallToScreen() { // 将内墙画到屏幕上
        for(let i = 0;i < insidewallData.length;i++) {
            let item = insidewallData[i]
            drawPoint(drawCtx, item.start.x, item.start.y)
            drawLine(drawCtx, item.start, item.end)
            drawPoint(drawCtx, item.end.x, item.end.y)
        }
    }

    function drawPoint(ctx, x, y, s = false, color = '#000000') { // 根据传入的坐标在指定的上下文绘制点, s 参数表示当前点是否被选中，默认未被选中
        ctx.beginPath()
        ctx.fillStyle = color
        ctx.strokeStyle = color
        if(s) {
            ctx.fillStyle = '#ff0000'
            ctx.strokeStyle = '#ff0000'
        }
        ctx.arc(x, y, 2, 0, 2*Math.PI)
        ctx.fill()
        ctx.beginPath()
        ctx.arc(x, y, 4, 0, 2*Math.PI)
        ctx.stroke()
        ctx.fillStyle = '#000000'
        ctx.strokeStyle = '#000000'
        if(s) {
            ctx.fillStyle = '#000000'
            ctx.strokeStyle = '#000000'
        }
    }

    function drawWin(p, l1, l2, parentWall) { // 绘制窗户 主要用于用户在移动鼠标的时候作辅助提示 默认窗子的宽为 20/1m 
        let len = 10
        if(l1.x == l2.x) { // 窗户在垂直的墙面上
            if(p.y + 6 <= Math.max(l1.y, l2.y) && !isCrashOtherWinOrDoor(p, {x: p.x, y: p.y + len})) { // 向上画窗户
                drawPoint(drawCtx, p.x, p.y, false, '#0000ff')
                drawPoint(drawCtx, p.x, p.y + len, false, '#0000ff')
                currentWin = { wp1: p, wp2: {x: p.x, y: p.y + len}, l1, l2, parentWall}
            }else if(p.y - 6 >= Math.min(l1.y, l2.y) && !isCrashOtherWinOrDoor(p, {x: p.x, y: p.y - len})) { // 向下画窗户
                drawPoint(drawCtx, p.x, p.y, false, '#0000ff')
                drawPoint(drawCtx, p.x, p.y - len, false, '#0000ff')
                currentWin = { wp1: p, wp2: {x: p.x, y: p.y - len}, l1, l2, parentWall }
            }
        }else{ // 窗户在水平的墙面上
            if(p.x + 6 <= Math.max(l1.x, l2.x) && !isCrashOtherWinOrDoor(p, {x: p.x + len, y: p.y})) { // 向左画窗户
                drawPoint(drawCtx, p.x, p.y, false, '#0000ff')
                drawPoint(drawCtx, p.x + len, p.y, false, '#0000ff')
                currentWin = { wp1: p, wp2: {x: p.x + len, y: p.y}, l1, l2, parentWall }
            }else if(p.x - 6 >= Math.min(l1.x, l2.x) && !isCrashOtherWinOrDoor(p, {x: p.x - len, y: p.y})) { // 向右画窗户
                drawPoint(drawCtx, p.x, p.y, false, '#0000ff')
                drawPoint(drawCtx, p.x - len, p.y, false, '#0000ff')
                currentWin = { wp1: p, wp2: {x: p.x - len, y: p.y}, l1, l2, parentWall }
            }
        }
    }

    function drawDoor(p, l1, l2, parentWall) {
        let len = 10
        if(l1.x == l2.x) { // 窗户在垂直的墙面上
            if(p.y + 6 <= Math.max(l1.y, l2.y) && !isCrashOtherWinOrDoor(p, {x: p.x, y: p.y + len})) { // 向上画窗户
                drawPoint(drawCtx, p.x, p.y, false, '#00ff00')
                drawPoint(drawCtx, p.x, p.y + len, false, '#00ff00')
                currentDoor = { dp1: p, dp2: {x: p.x, y: p.y + len}, l1, l2, parentWall }
            }else if(p.y - 6 >= Math.min(l1.y, l2.y) && !isCrashOtherWinOrDoor(p, {x: p.x, y: p.y - len})) { // 向下画窗户
                drawPoint(drawCtx, p.x, p.y, false, '#00ff00')
                drawPoint(drawCtx, p.x, p.y - len, false, '#00ff00')
                currentDoor = { dp1: p, dp2: {x: p.x, y: p.y - len}, l1, l2, parentWall }
            }
        }else{ // 窗户在水平的墙面上
            if(p.x + 6 <= Math.max(l1.x, l2.x) && !isCrashOtherWinOrDoor(p, {x: p.x + len, y: p.y})) { // 向左画窗户
                drawPoint(drawCtx, p.x, p.y, false, '#00ff00')
                drawPoint(drawCtx, p.x + len, p.y, false, '#00ff00')
                currentDoor = { dp1: p, dp2: {x: p.x + len, y: p.y}, l1, l2, parentWall }
            }else if(p.x - 6 >= Math.min(l1.x, l2.x) && !isCrashOtherWinOrDoor(p, {x: p.x - len, y: p.y})) { // 向右画窗户
                drawPoint(drawCtx, p.x, p.y, false, '#00ff00')
                drawPoint(drawCtx, p.x - len, p.y, false, '#00ff00')
                currentDoor = { dp1: p, dp2: {x: p.x - len, y: p.y}, l1, l2, parentWall }
            }
        }
    }

    function isCrashOtherWinOrDoor(p1, p2) { // 与其他的窗户和门之间是否会发生碰撞 p1-p2 表示
        for(let i = 0;i< winData.length;i++) {
            let win = winData[i]
            if(p1.x == p2.x && win.wp1.x == win.wp2.x && p1.x == win.wp1.x) { // 垂直
                if((Math.abs(p1.y - p2.y) + Math.abs(win.wp1.y - win.wp2.y)) > 
                (Math.max(p1.y,p2.y,win.wp1.y,win.wp2.y) - Math.min(p1.y,p2.y,win.wp1.y,win.wp2.y)) ) { // 有重叠部分
                    return true // 发生碰撞
                }
            }
            if(p1.y == p2.y && win.wp1.y == win.wp2.y && p1.y == win.wp1.y) { // 水平
                if((Math.abs(p1.x - p2.x) + Math.abs(win.wp1.x - win.wp2.x)) > 
                (Math.max(p1.x,p2.x,win.wp1.x,win.wp2.x) - Math.min(p1.x,p2.x,win.wp1.x,win.wp2.x)) ) { // 有重叠部分
                    return true // 发生碰撞
                }
            }
        } 

        for(let i = 0;i < doorData.length;i++) {
            let door = doorData[i]
            if(p1.x == p2.x && door.dp1.x == door.dp2.x && p1.x == door.dp1.x) { // 垂直
                if((Math.abs(p1.y - p2.y) + Math.abs(door.dp1.y - door.dp2.y)) > 
                (Math.max(p1.y,p2.y,door.dp1.y,door.dp2.y) - Math.min(p1.y,p2.y,door.dp1.y,door.dp2.y)) ) { // 有重叠部分
                    return true // 发生碰撞
                }
            }
            if(p1.y == p2.y && door.dp1.y == door.dp2.y && p1.y == door.dp1.y) { // 水平
                if((Math.abs(p1.x - p2.x) + Math.abs(door.dp1.x - door.dp2.x)) > 
                (Math.max(p1.x,p2.x,door.dp1.x,door.dp2.x) - Math.min(p1.x,p2.x,door.dp1.x,door.dp2.x)) ) { // 有重叠部分
                    return true // 发生碰撞
                }
            }
        }
        return false // 没有发生碰撞
    }

    function addWinToSideWallData(data) { // 将窗户的数据插入到墙壁的数据结构中 
        // console.log(data)
        if(data.parentWall == 'sideWall') {
            // console.log('t')
             if(Math.min(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2)) == 0 && 
            Math.max(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2)) == sidewallData.length -1
            ) {
                sidewallData[0].children.push({
                    type: 'win',
                    start: { x: data.wp1.x, y: data.wp1.y },
                    end: { x: data.wp2.x, y: data.wp2.y }
                })
            }else { // 不是最后的一条线段
                sidewallData[Math.max(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2))].children.push({
                    type: 'win',
                    start: { x: data.wp1.x, y: data.wp1.y },
                    end: { x: data.wp2.x, y: data.wp2.y }
                })
            }
        }else { // insideWall
            for(let i = 0;i < insidewallData.length;i++) {
                let wall = insidewallData[i]
                if(JSON.stringify(data.l1) == JSON.stringify(wall.start) && 
                JSON.stringify(data.l2) == JSON.stringify(wall.end)){
                    wall.children.push({ // 正面的窗户
                        type: 'win',
                        start: { x: data.wp1.x, y: data.wp1.y },
                        end: { x: data.wp2.x, y: data.wp2.y }
                    })
                }
            }
            for(let i = 0;i < insidewallData.length;i++) {
                let wall = insidewallData[i]
                if(JSON.stringify(data.l1) == JSON.stringify(wall.end) && 
                JSON.stringify(data.l2) == JSON.stringify(wall.start)){
                    wall.children.push({ // 反面的窗户
                        type: 'win',
                        start: { x: data.wp2.x, y: data.wp1.y },
                        end: { x: data.wp1.x, y: data.wp2.y }
                    })
                }
            }
        }
       
    }

    function addDoorToSideWallData(data) {// 将门的数据插入到墙壁的数据结构中
        if(data.parentWall == 'sideWall') {
            if(Math.min(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2)) == 0 && 
            Math.max(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2)) == sidewallData.length -1
            ) {
                sidewallData[0].children.push({
                    type: 'door',
                    start: { x: data.dp1.x, y: data.dp1.y },
                    end: { x: data.dp2.x, y: data.dp2.y }
                })
            }else { // 不是最后的一条线段
                sidewallData[Math.max(sidewallData.indexOf(data.l1), sidewallData.indexOf(data.l2))].children.push({
                    type: 'door',
                    start: { x: data.dp1.x, y: data.dp1.y },
                    end: { x: data.dp2.x, y: data.dp2.y }
                })
            }
        }else { // insideWall
            for(let i = 0;i < insidewallData.length;i++) {
                let wall = insidewallData[i]
                if(JSON.stringify(data.l1) == JSON.stringify(wall.start) && 
                JSON.stringify(data.l2) == JSON.stringify(wall.end)){
                    wall.children.push({ // 正面的门
                        type: 'door',
                        start: { x: data.dp1.x, y: data.dp1.y },
                        end: { x: data.dp2.x, y: data.dp2.y }
                    })
                }
            }
            for(let i = 0;i < insidewallData.length;i++) {
                let wall = insidewallData[i]
                if(JSON.stringify(data.l1) == JSON.stringify(wall.end) && 
                JSON.stringify(data.l2) == JSON.stringify(wall.start)){
                    wall.children.push({ // 反面的门
                        type: 'door',
                        start: { x: data.dp2.x, y: data.dp1.y },
                        end: { x: data.dp1.x, y: data.dp2.y }
                    })
                }
            }
        }
       
    }

    function getInsideWallRotation(insidewall) { // 获取内墙壁对象的旋转角度
        let start = insidewall.start
        let end = insidewall.end
        if(start.x < end.x && start.y == end.y) { // 右
            return 0
        }else if(start.x == end.x && start.y < end.y) { // 下
            return -Math.PI / 2
        }else if(start.x > end.x && start.y == end.y) { // 左
            return -Math.PI
        }else if(start.x == end.x && start.y > end.y) { // 上
            return -3*Math.PI/2
        }
    }

    function getPointRotation(startPoint, endPoint) { // 判断一条线段的旋转角度 (判断的线段已经经过直角调整)
        if(endPoint.x >= startPoint.x && endPoint.y == startPoint.y) {      // 右
            return 0
        }else if(endPoint.x == startPoint.x && endPoint.y >= startPoint.y) {// 下
            return -Math.PI / 2
        }else if(endPoint.x < startPoint.x && endPoint.y == startPoint.y) { // 左
            return -Math.PI
        }else if(endPoint.x == startPoint.x && endPoint.y < startPoint.y) { // 上
            return -3*Math.PI/2
        }
    }

    function adjustLastPointPos() { // 调整最后一个点的位置，以适应直角
        let lastPoint = sidewallData[sidewallData.length - 1]
        let firstPoint = sidewallData[0]
        let p = { x: lastPoint.x, y: lastPoint.y }
       
        if(sidewallData[0].x == sidewallData[1].x) {        // 起始线段垂直
            p.y = firstPoint.y
        }else if(sidewallData[0].y == sidewallData[1].y){   // 起始线段水平
            p.x = firstPoint.x
        }
        return p
    }

    function adjustPointPos(lastPoint, currentPoint) { // 调整绘制点的位置 （主要是控制直角墙面， 暂时不考虑斜角）
        let distance = pointsDistance(lastPoint, currentPoint)
        let xLen = Math.abs(currentPoint.x - lastPoint.x)
        let yLen = Math.abs(currentPoint.y - lastPoint.y)

        if(currentPoint.x >= lastPoint.x && currentPoint.y >= lastPoint.y) {        // 右上
            if(xLen > yLen) {
                return { x: lastPoint.x + distance, y: lastPoint.y }
            }else {
                return { x: lastPoint.x, y: lastPoint.y + distance }
            }
        }else if(currentPoint.x >= lastPoint.x && currentPoint.y < lastPoint.y){    // 右下
            if(xLen > yLen) {
                return { x: lastPoint.x + distance, y: lastPoint.y }
            }else {
                return { x: lastPoint.x, y: lastPoint.y - distance }
            }
        }else if(currentPoint.x < lastPoint.x && currentPoint.y <= lastPoint.y){    // 左下
            if(xLen > yLen) {
                return { x: lastPoint.x - distance, y: lastPoint.y }
            }else {
                return { x: lastPoint.x, y: lastPoint.y - distance }
            }
        }else if(currentPoint.x < lastPoint.x && currentPoint.y > lastPoint.y){     // 左上
            if(xLen > yLen) {
                return { x: lastPoint.x - distance, y: lastPoint.y }
            }else {
                return { x: lastPoint.x, y: lastPoint.y + distance }
            }
        }
    }

    function isNewInSideWallUseful(p1, p2) { // 判断新增内墙是否有效 主要是判断新增内墙是否与现有墙壁相交
        
        if(!isNewSideWallUseful(p1, p2, sidewallData)) return false // 当前内墙会与外墙相交

        for(let i = 0;i < insidewallData.length;i++) { // 判断是否与内墙有相交
            let item = insidewallData[i]
            
            if(isLineIntersect(p1, p2, item.start, item.end)) return false
        }
        
        return true // 没有相交
    }

    function isNewSideWallUseful(p1, p2, points) { // 判断新增外墙是否有效 主要是判断新增外墙是否与现有外墙相交
        for(let i = 0;i < points.length - 1;i++) {
            if(isLineIntersect(p1, p2, points[i], points[i+1])) {
                // console.log('corss')
                return false
            }
        }
        if(isLineIntersect(p1, p2, points[points.length - 1], points[0])) {
            return false
        }
        // console.log('no-cross')
        return true
    }

    function isPointInShape(pt, poly) { // 判断传入的点是否在外墙图形的内部
        for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) 
            ((poly[i].y <= pt.y && pt.y < poly[j].y) || (poly[j].y <= pt.y && pt.y < poly[i].y)) 
            && (pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) 
            && (c = !c); 
        return c; 
    }

    function isLineIntersect(p1, p2, p3, p4) { // 判断线段 p1-p2 与线段 p3-p4 是否相交 用于检测用户新增的点是否有效
        
        if((p1.x == p2.x && p3.y == p4.y)) {
           
            if(Math.max(p1.y, p2.y) > p3.y && 
            Math.min(p1.y, p2.y) < p3.y &&
            Math.max(p3.x, p4.x) > p1.x &&
            Math.min(p3.x, p4.x) < p1.x
            ) {
                // console.log(p1, p2, p3, p4)
                // console.log(11)
                // console.log(Math.min(p1.y, p2.y) < p3.y)
                // console.log(Math.min(p3.x, p4.x) < p1.x)
                return true // cross
            }
            return false // no-cross
        }else if(p1.y == p2.y && p3.x == p4.x) {
            if(Math.max(p1.x, p2.x) > p3.x && 
            Math.min(p1.x, p2.x) < p3.x &&
            Math.max(p3.y, p4.y) > p1.y &&
            Math.min(p3.y, p4.y) < p1.y
            ) {
                return true // cross
            }
            return false // no-cross
        }else if(p1.x == p2.x && p3.x == p4.x) {
           
            if(p1.x == p3.x &&
                (Math.max(p1.y, p2.y, p3.y, p4.y) - Math.min(p1.y, p2.y, p3.y, p4.y)) < 
                (Math.abs(p1.y - p2.y) + Math.abs(p3.y - p4.y))
            ){
                return true
            }
            return false
        }else if(p1.y == p2.y && p3.y == p4.y) {
            
            if(p1.y == p3.y &&
                (Math.max(p1.x, p2.x, p3.x, p4.x) - Math.min(p1.x, p2.x, p3.x, p4.x)) < 
                (Math.abs(p1.x - p2.x) + Math.abs(p3.x - p4.x))
            ){
                return true
            }
            return false
        }
    }

    function isEven(n) { // 判断传入的数值是否是偶数
        return n%2 === 0
    }

    function isSelectPoint(p) { // 判断点击的位置是否选中了墙壁的一个点
        for(let i = 0;i < sidewallData.length;i++) { // 外墙的点
            if(pointsDistance(p, sidewallData[i]) < 8) {
                return { x: sidewallData[i].x, y: sidewallData[i].y }
            }
        }

        for(let i = 0;i < insidewallData.length;i++) { // 内墙的点
            if(pointsDistance(p, insidewallData[i].start) < 8) {
                return { x: insidewallData[i].start.x, y: insidewallData[i].start.y }
            }

            if(pointsDistance(p, insidewallData[i].end) < 8) {
                return { x: insidewallData[i].end.x, y: insidewallData[i].end.y }
            }
        }

        return null // 用户没有选中墙壁的边界点
    }

    function isSelectInSideWall(p) { // 根据传入的点击点位判断拥有有没有选中内墙
        for(let i = 0;i < insidewallData.length;i++) {
            let l1 = insidewallData[i].start
            let l2 = insidewallData[i].end
            let dis = pointToLine(p, l1, l2)
            if(dis < 4) return [p, l1, l2]
        }
        return []
    }

    function isSelectSideWall(p) { // 根据传入的点击点位判断拥有有没有选中外墙 
        for(let i = 0;i < sidewallData.length;i++) { // 与当前外墙的每一条线段做对比
            if(i < sidewallData.length - 1) { // 不是最后一个点
                let l1 = sidewallData[i]
                let l2 = sidewallData[i+1]
                let dis = pointToLine(p, l1, l2)
                if(dis < 4) {
                    return [p, l1, l2]
                }
            }else { // 最后一个点
                let l1 = sidewallData[i]
                let l2 = sidewallData[0]
                let dis = pointToLine(p, l1, l2)
                if(dis < 4) {
                    return [p, l1, l2]
                }
            }
        }
        return []
    }

    function getInLinePoint(p, l1, l2) { // 判断点 p 到线段 l1-l2 的垂足 (l1-l2 线段水平或垂直)
        if(l1.y == l2.y) { // l1-l2 水平
            return { x: p.x, y: l1.y }
        }else { // l1-l2 垂直
            return { x: l1.x, y: p.y }
        }
    }

    function pointToLine(p, l1, l2) { // 判断点 p 到线段 l1-l2 的距离 (l1-l2 线段水平或垂直)
        if(l1.y == l2.y) { // l1-l2 水平
            if(p.x > Math.max(l1.x, l2.x) || p.x < Math.min(l1.x, l2.x)) { // 过滤非范围内的点
                return 100
            }
            return Math.abs(p.y - l1.y)
        }else { // l1-l2 垂直
            if(p.y > Math.max(l1.y, l2.y) || p.y < Math.min(l1.y, l2.y)) { // 过滤非范围内的点
                return 100
            }
            return Math.abs(p.x - l1.x)
        }
    }
 
    function pointsDistance(p1, p2) { // 返回两点之间的距离
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2))
    }
    
    function initBgGrid() { // 初始化背景的网格线
        // 背景的宽高是包围框的两倍
        let bgcanvas = document.getElementById('bgplane') 
        let bgwidth = bgcanvas.clientWidth*2
        let bgheight = bgcanvas.clientHeight*2
        bgcanvas.width = bgwidth
        bgcanvas.height = bgheight
        bgctx = bgcanvas.getContext('2d')
        drawBgGrid(bgctx, bgwidth, bgheight)
    }

    function drawBgGrid( bgctx, bgwidth, bgheight) { // 绘制背景的网格线
        bgctx.globalAlpha = 0.3
        let widthCount = grid_widthCount, widthLen = bgwidth / widthCount
        let heightCount = grid_heightCout, heightLen = bgheight / heightCount

        for(let i = 0;i < widthCount;i++) { // 横线
            drawLine(bgctx, { x: widthLen * i, y: 0 }, { x: widthLen * i, y: bgheight } )
        }

        for(let j = 0;j < heightCount;j++) { // 竖线
            drawLine(bgctx, { x: 0, y: heightLen * j }, { x: bgwidth, y: heightLen * j } )
        }
        bgctx.globalAlpha = 1
    }

    function drawLine(ctx, from, to, color = '#000000') { // 从指定的上下文中，根据传入的两个点的坐标画线
        ctx.beginPath()
        ctx.strokeStyle = color
        ctx.moveTo(from.x, from.y)
        ctx.lineTo(to.x, to.y)
        ctx.stroke()
        ctx.strokeStyle = '#000000'
    }

    function outData() { // 输出当前制图的数据
        let sideData = transformSideWall()
        let insideData = transformInSideWall()
        let groundData = transformGround()
        // console.log(JSON.stringify([...sideData]))
        // console.log(sideData)
        // console.log(JSON.stringify([...groundData]))
        // console.log(JSON.stringify([...insideData]))
        // console.log(insideData)
        // console.log(JSON.stringify([...sideData, ...groundData]))
        console.log(JSON.stringify([...sideData, ...groundData, ...insideData]))
        // console.log(JSON.stringify(insidewallData))
    }

    function changeType(type) { // 改变当前正在绘制的墙壁的类型
        let title = document.getElementById('currentType')
        title.innerText = type
        type = type
        currentType.type = type
        drawCanvas.removeEventListener('mousemove', handleMove)
        if(type == 'win' || type == 'door') {
            drawCanvas.addEventListener('mousemove', handleMove)
        }
    }

    function transformSideWall() { // 根据现有数据生成外墙中间数据 {// wall1
        let xArr = [], yArr = []
        for(let i = 0;i < sidewallData.length;i++) {
            xArr.push(sidewallData[i].x)
            yArr.push(sidewallData[i].y)
        }
        let minX = Math.min(...xArr)
        let minY = Math.min(...yArr)
        let sidewall = []
        for(let i = 0;i < sidewallData.length;i++) {
            if(i < sidewallData.length - 1) { // 不是最后一个点
                let current = sidewallData[i]
                let next = sidewallData[i+1]
                let childArr = []
                for(let j = 0;j < next.children.length;j++) {
                    let p = next.children[j]
                    childArr.push({
                        type: p.type,
                        start: { x: WIDTH*(p.start.x - minX)/wrapWidth, y:  HEIGHT*(p.start.y - minY)/wrapHeight },
                        end: { x: WIDTH*(p.end.x - minX)/wrapWidth, y:  HEIGHT*(p.end.y - minY)/wrapHeight }
                    })
                }
                sidewall.push({
                    type: 'sideWall',
                    start: { x: WIDTH*(current.x - minX)/wrapWidth, y: HEIGHT*(current.y - minY)/wrapHeight },
                    end: { x: WIDTH*(next.x - minX)/wrapWidth, y: HEIGHT*(next.y - minY)/wrapHeight },
                    children: childArr,
                    rotation: next.rotation
                })
            }else { // 最后一个点
                let current = sidewallData[i]
                let next = sidewallData[0]
                let childArr = []
                for(let j = 0;j < next.children.length;j++) {
                    let p = next.children[j]
                    childArr.push({
                        type: p.type,
                        start: { x: WIDTH*(p.start.x - minX)/wrapWidth, y:  HEIGHT*(p.start.y - minY)/wrapHeight },
                        end: { x: WIDTH*(p.end.x - minX)/wrapWidth, y:  HEIGHT*(p.end.y - minY)/wrapHeight }
                    })
                    
                }
                sidewall.push({
                    type: 'sideWall',
                    start: { x: WIDTH*(current.x - minX)/wrapWidth, y: HEIGHT*(current.y - minY)/wrapHeight },
                    end: { x: WIDTH*(next.x - minX)/wrapWidth, y: HEIGHT*(next.y - minY)/wrapHeight },
                    children: childArr,
                    rotation: next.rotation
                })
            }
        }
        // return sidewall
        // console.log(sidewall)
        return transformWalls(sidewall)
    }

    function transformInSideWall() { //  根据现有数据生成内墙中间数据
        let xArr = [], yArr = []
        for(let i = 0;i < sidewallData.length;i++) {
            xArr.push(sidewallData[i].x)
            yArr.push(sidewallData[i].y)
        }
        let minX = Math.min(...xArr)
        let minY = Math.min(...yArr)
        let insidewall = []
        // console.log(JSON.stringify(insidewallData))
        // console.log(insidewallData)
        for(let i = 0;i < insidewallData.length;i++) {
                let current = insidewallData[i]
                let childArr = []
                for(let j = 0;j < current.children.length;j++) {
                    let p = current.children[j]
                    childArr.push({
                        type: p.type,
                        start: { x: WIDTH*(p.start.x - minX)/wrapWidth, y:  HEIGHT*(p.start.y - minY)/wrapHeight },
                        end: { x: WIDTH*(p.end.x - minX)/wrapWidth, y:  HEIGHT*(p.end.y - minY)/wrapHeight }
                    })
                }
                insidewall.push({
                    type: 'insideWall',
                    start: { x: WIDTH*(current.start.x - minX)/wrapWidth, y: HEIGHT*(current.start.y - minY)/wrapHeight },
                    end: { x: WIDTH*(current.end.x - minX)/wrapWidth, y: HEIGHT*(current.end.y - minY)/wrapHeight },
                    children: childArr,
                    rotation: current.rotation
                })
        }
        // console.log(insidewall)
        return transformWalls(insidewall)
    }

    function transformGround() { //  根据现有数据生成地面和天花板中间数据
        let xArr = [], yArr = []
        for(let i = 0;i < sidewallData.length;i++) {
            xArr.push(sidewallData[i].x)
            yArr.push(sidewallData[i].y)
        }
        let minX = Math.min(...xArr)
        let minY = Math.min(...yArr)

        let groundwall = []
        for(let i = 0;i < sidewallData.length;i++) {
            if(i < sidewallData.length - 1) { // 不是最后一个点
                let current = sidewallData[i]
                let next = sidewallData[i+1]
                groundwall.push({
                    type: 'sideWall',
                    start: { x: WIDTH*(current.x - minX)/wrapWidth, y: HEIGHT*(current.y - minY)/wrapHeight },
                    end: { x: WIDTH*(next.x - minX)/wrapWidth, y: HEIGHT*(next.y - minY)/wrapHeight },
                    children: [],
                    rotation: next.rotation
                })
            }else { // 最后一个点
                let current = sidewallData[i]
                let next = sidewallData[0]
                groundwall.push({
                    type: 'sideWall',
                    start: { x: WIDTH*(current.x - minX)/wrapWidth, y: HEIGHT*(current.y - minY)/wrapHeight },
                    end: { x: WIDTH*(next.x - minX)/wrapWidth, y: HEIGHT*(next.y - minY)/wrapHeight },
                    children: [],
                    rotation: next.rotation
                })
            }
        }

        let fpoints = []
        let rpoints = []
        for(let i = 0;i < groundwall.length;i++) {
            fpoints.push({ x: groundwall[i].start.x, y: groundwall[i].start.y * -1 })
            rpoints.push({ x: groundwall[i].start.x * -1, y: groundwall[i].start.y * -1 })
        }
        fpoints.push({ x: groundwall[0].start.x, y: groundwall[0].start.y * -1 })
        rpoints.push({ x: groundwall[0].start.x * -1, y: groundwall[0].start.y * -1 })
        return [
            {
                type: 'floor',      // 地面
                children: [],
                start: fpoints[0],
                path: fpoints,
                position: { x: 0, y: 0, z: 0},
                rotation: { x: -Math.PI/2, y: 0 }
            },
            {
                type: 'roof',    
                children: [],
                start: rpoints[0],
                path: rpoints,
                position: { x: 0, y: 30, z: 0},
                rotation: { x: -Math.PI/2, y: Math.PI }
            }
        ]

    }

    function transformWalls(walls) { // 将墙壁数值的中间数据结构二次转换
        let data = []
        for(let i = 0;i < walls.length;i++) {
                let wall = walls[i], children = []
                let len = Math.sqrt(Math.pow(wall.start.x - wall.end.x, 2) + Math.pow(wall.start.y - wall.end.y, 2))
                for(let j = 0;j < wall.children.length; j++) {
                    let item = {}, child = wall.children[j]
                    item.type = child.type
                    let startX =  Math.sqrt(Math.pow(wall.start.x - child.start.x, 2) + Math.pow(wall.start.y - child.start.y, 2))
                    item.start = { x: startX, y: 10 }
                    let childLen = Math.sqrt(Math.pow(child.start.x - child.end.x, 2) + Math.pow(child.start.y - child.end.y, 2))
                    item.path = [
                        { x: startX, y: 20 },
                        { x: startX + childLen, y: 20 },
                        { x: startX + childLen, y: child.type=='win'?10:0 },
                        { x: startX, y: child.type=='win'?10:0 }
                    ]
                    children.push(item)
                }
                data.push({
                    type: wall.type,
                    children, 
                    start: { x: 0, y: 0 },
                    path: [
                        { x: 0, y: 30 },
                        { x: len, y: 30 },
                        { x: len, y: 0 },
                        { x: 0, y: 0 }
                    ],
                    position: { x: wall.start.x, y: 0, z: wall.start.y },
                    rotation: { x: 0, y: wall.rotation }
                })
            } 
            return data
    }

    function reset() { // 重新设置画布大小
        wrap = document.getElementById('canWrap')
        wrapWidth = wrap.clientWidth
        wrapHeight = wrap.clientHeight // 画布基准大小
        // console.log(wrapWidth)
    }
</script>
</html>